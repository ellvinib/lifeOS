
 ▐▛███▜▌   Claude Code v2.0.22
▝▜█████▛▘  Sonnet 4.5 · Claude Max
  ▘▘ ▝▝    /Users/vincentbouillart/ai-git/lifeOS/.trees/email

> ultrathink we want to add a system module that each module kan use this 
module will be able to read all your emails other emails that want to can
listen to events if an email is comming in we will focus on outlook, gmail
and smtp connection thin how this fit in the architecture of our app and how
 we can implement this other modules can then receiving emails an do
something with it or read specific mails also think how can we do this
witouth using much space and cheap hosting options that if someone get a lot
 of mail we do not waste resources how will we do this

⏺ I'll think through how to architect an email integration module that fits
  your clean architecture while being resource-efficient and cost-effective.

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Let me analyze the
                                                requirements:\n1. Email module
                                                that other modules can use
                                                (shared infrastructure
                                                module)\n2. Support Gmail,
                                                Outlook, and SMTP
                                                connections\n3. Publish events
                                                when emails arrive
                                                (event-driven)\n4. Other modules
                                                 can listen to events and read
                                                specific emails\n5. Must be
                                                resource-efficient (minimal
                                                storage, cheap hosting)\n6.
                                                Handle high email volumes
                                                without waste\n\nThis needs to
                                                fit into their existing
                                                architecture:\n- Event-driven
                                                modular monolith\n- Clean
                                                architecture (Domain,
                                                Application, Infrastructure,
                                                Presentation)\n- IModule
                                                interface\n- PostgreSQL + Redis
                                                + BullMQ\n- Event bus for
                                                inter-module communication",
                                                thoughtNumber: 1, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 1,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Key architectural
                                                insight: Store METADATA only,
                                                not full email
                                                content.\n\nStrategy:\n- Store
                                                minimal email metadata in
                                                PostgreSQL (from, to, subject,
                                                timestamp, messageId,
                                                hasAttachments)\n- Keep actual
                                                emails in provider's storage
                                                (Gmail/Outlook servers)\n- Fetch
                                                 full content on-demand when
                                                modules request it\n- Cache
                                                frequently accessed emails in
                                                Redis with TTL\n- Use lazy
                                                loading pattern\n\nThis reduces
                                                storage from ~10GB for 10,000
                                                emails to ~10MB
                                                metadata.\n\nMetadata to
                                                store:\n- providerMessageId
                                                (Gmail/Outlook's ID)\n- from,
                                                to, cc, subject\n- timestamp,
                                                threadId\n- snippet (first 200
                                                chars)\n- hasAttachments,
                                                attachmentCount\n- labels,
                                                isRead, isStarred\n- sizeBytes
                                                (for tracking)\n\nDON'T
                                                store:\n- Full email body\n-
                                                Attachments\n- HTML content",
                                                thoughtNumber: 2, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 2,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Email detection
                                                strategy - Push over Pull for
                                                efficiency:\n\n**Gmail:**\n- Use
                                                 Gmail API with Cloud Pub/Sub
                                                push notifications (free)\n- Set
                                                 up watch on mailbox\n- Receive
                                                webhook when new email
                                                arrives\n- No polling needed →
                                                saves API
                                                quota\n\n**Outlook:**\n- Use
                                                Microsoft Graph API with
                                                webhooks (free)\n- Subscribe to
                                                mailFolder changes\n- Receive
                                                webhook notifications\n- No
                                                polling
                                                needed\n\n**SMTP/IMAP:**\n- Use
                                                IMAP IDLE command (push-like)\n-
                                                 Maintains connection, server
                                                notifies of new emails\n-
                                                Fallback to periodic polling if
                                                IDLE not
                                                supported\n\n**Efficiency
                                                gains:**\n- Push notifications =
                                                 near real-time, no wasted API
                                                calls\n- Only sync when emails
                                                actually arrive\n- Drastically
                                                reduced API quota usage\n- Lower
                                                 server resource usage (no
                                                constant polling)",
                                                thoughtNumber: 3, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 3,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Event-driven
                                                processing flow (lazy loading
                                                pattern):\n\n```\n1. Email
                                                arrives at Gmail/Outlook\n
                                                ↓\n2. Provider sends webhook to
                                                Email Module\n   ↓\n3. Email
                                                Module syncs METADATA only\n
                                                ↓\n4. Email Module publishes
                                                EmailReceived event to
                                                EventBus\n   {\n     emailId,
                                                accountId, from, to, subject,\n
                                                    snippet, timestamp,
                                                hasAttachments, labels\n   }\n
                                                 ↓\n5. Other modules listen and
                                                decide if interested\n   -
                                                Finance: \"Does subject contain
                                                'invoice'?\"\n   - Garden: \"Is
                                                from='garden-supplier@example.co
                                                m'?\"\n   ↓\n6. If interested,
                                                module requests full content\n
                                                 emailModule.getEmail(emailId)\n
                                                   ↓\n7. Email Module checks
                                                Redis cache\n   - If cached:
                                                return immediately\n   - If not:
                                                 fetch from provider → cache →
                                                return\n   ↓\n8. Module
                                                processes full email
                                                content\n```\n\nBenefits:\n-
                                                Only fetch full emails when
                                                needed\n- Multiple modules can
                                                react to same email\n- Loose
                                                coupling via events\n- Minimal
                                                initial storage\n- Cache
                                                prevents duplicate API calls",
                                                thoughtNumber: 4, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 4,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Module classification
                                                 and dependencies:\n\nThe Email
                                                module is a **Shared
                                                Infrastructure Module** (like
                                                authentication or
                                                logging):\n\nDependency
                                                hierarchy:\n```\nCore\n  ↑
                                                depends on\nEmail Module (shared
                                                 infrastructure)\n  ↑ depends
                                                on\nDomain Modules (Finance,
                                                Garden, House Maintenance,
                                                etc.)\n```\n\nEmail Module
                                                characteristics:\n- Other
                                                modules depend on it\n- It
                                                doesn't depend on domain
                                                modules\n- Only depends on Core
                                                (EventBus, IModule, errors,
                                                Result)\n- Provides services to
                                                other modules\n- No business
                                                logic (just
                                                integration)\n\nModule interface
                                                 implementation:\n```typescript\
                                                nclass EmailModule implements
                                                IModule {\n  name = 'email'\n
                                                version = '1.0.0'\n  \n  //
                                                Publishes events for other
                                                modules\n  // Provides query
                                                interface (getEmail,
                                                searchEmails)\n  // Manages
                                                email accounts\n  // Coordinates
                                                 provider
                                                integrations\n}\n```\n\nOther
                                                modules use it
                                                like:\n```typescript\n// Finance
                                                 module listening to events\neve
                                                ntBus.subscribe('EmailReceived',
                                                 async (event) => {\n  if
                                                (isInvoiceEmail(event.payload))
                                                {\n    const email = await
                                                emailModule.getEmail(event.paylo
                                                ad.emailId);\n    await
                                                processInvoice(email);\n
                                                }\n});\n```", thoughtNumber: 5,
                                                totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 5,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Clean Architecture
                                                layers for Email
                                                Module:\n\n**Domain Layer:**\n-
                                                Entities: Email, EmailAccount,
                                                EmailThread\n- Value Objects:
                                                EmailAddress, EmailProvider
                                                (enum), EmailFilter\n-
                                                Interfaces: IEmailRepository,
                                                IEmailAccountRepository,
                                                IEmailProvider\n- Business rules
                                                 in entities (e.g.,
                                                Email.isFromDomain(), Email.hasK
                                                eyword())\n\n**Application
                                                Layer:**\n- Use Cases:
                                                ConnectAccountUseCase,
                                                SyncEmailsUseCase,
                                                GetEmailUseCase,
                                                SearchEmailsUseCase\n- Services:
                                                 EmailSyncService (coordinates
                                                syncing), EmailEventService
                                                (publishes events)\n- DTOs:
                                                EmailDTO, EmailAccountDTO with
                                                mappers\n- No direct
                                                dependencies on external
                                                APIs\n\n**Infrastructure
                                                Layer:**\n- Providers:
                                                GmailProvider, OutlookProvider,
                                                SmtpProvider (implement
                                                IEmailProvider)\n- Repositories:
                                                 EmailRepository,
                                                EmailAccountRepository
                                                (Prisma)\n- Cache:
                                                EmailCacheService (Redis)\n-
                                                Jobs: EmailSyncJob,
                                                EmailCleanupJob (BullMQ)\n-
                                                Webhooks: GmailWebhookHandler,
                                                OutlookWebhookHandler\n\n**Prese
                                                ntation Layer:**\n- Controllers:
                                                 EmailController,
                                                EmailAccountController\n-
                                                Routes: email.routes,
                                                email-account.routes,
                                                webhook.routes\n- Validation:
                                                Zod schemas\n\nDependency flow:
                                                Presentation → Application →
                                                Domain ← Infrastructure\nDomain
                                                knows nothing about
                                                Gmail/Outlook/SMTP specifics!",
                                                thoughtNumber: 6, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 6,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Cost optimization
                                                strategies for high email
                                                volumes:\n\n**1. Intelligent
                                                Metadata Retention Policy:**\n-
                                                Keep metadata for all emails
                                                (tiny storage cost)\n-
                                                Auto-delete metadata older than
                                                X months (configurable)\n-
                                                Archive important emails only
                                                (user-flagged or
                                                module-requested)\n\n**2. Smart
                                                Caching with Redis:**\n- Cache
                                                recently accessed full emails
                                                (1-hour TTL)\n- LRU eviction
                                                when memory limit reached\n-
                                                Compressed email content in
                                                cache\n- Track cache hit
                                                rate\n\n**3. Rate Limiting &
                                                Batching:**\n- Batch metadata
                                                syncs (every 5 minutes for SMTP,
                                                 real-time for webhooks)\n- Rate
                                                 limit full email fetches per
                                                module\n- Queue email processing
                                                 jobs to prevent API quota
                                                exhaustion\n\n**4. Storage Costs
                                                 (example for 50,000
                                                emails/year):**\n- PostgreSQL
                                                metadata: ~50MB/year (~200
                                                bytes/email × 50K)\n- Redis
                                                cache: ~50MB (100 emails × 500KB
                                                 average)\n- Total: ~100MB vs
                                                ~25GB if storing full emails\n-
                                                Cost: $0.01/month vs $2.50/month
                                                 (250x reduction)\n\n**5. API
                                                Quota Management:**\n- Gmail: 1
                                                billion quota units/day
                                                (free)\n- Outlook: 10,000
                                                requests/10 minutes (free)\n-
                                                Push notifications use NO
                                                quota\n- Only fetch full emails
                                                on-demand (maybe 5% of
                                                emails)\n\n**6. Background
                                                Cleanup Jobs:**\n- Daily: Remove
                                                 metadata > 90 days old\n-
                                                Weekly: Clear unread emails from
                                                 deleted accounts\n- Monthly:
                                                Archive important emails if
                                                needed", thoughtNumber: 7,
                                                totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 7,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Module structure and
                                                file organization following
                                                existing patterns:\n\n```\npacka
                                                ges/modules/email/\n├── src/\n│
                                                  ├── domain/\n│   │   ├──
                                                entities/\n│   │   │   ├──
                                                Email.ts              (~300
                                                lines - rich domain model)\n│
                                                │   │   ├── EmailAccount.ts
                                                  (~250 lines)\n│   │   │   └──
                                                EmailThread.ts        (~200
                                                lines)\n│   │   ├──
                                                value-objects/\n│   │   │   ├──
                                                EmailAddress.ts       (~100
                                                lines)\n│   │   │   ├──
                                                EmailProvider.ts      (~50 lines
                                                 - enum + helpers)\n│   │   │
                                                └── EmailFilter.ts        (~150
                                                lines)\n│   │   └──
                                                interfaces/\n│   │       ├──
                                                IEmailRepository.ts\n│   │
                                                 ├──
                                                IEmailAccountRepository.ts\n│
                                                │       └── IEmailProvider.ts
                                                  (adapter interface)\n│   │\n│
                                                  ├── application/\n│   │   ├──
                                                use-cases/\n│   │   │   ├──
                                                ConnectAccountUseCase.ts\n│   │
                                                  │   ├──
                                                SyncEmailsUseCase.ts\n│   │   │
                                                  ├── GetEmailUseCase.ts\n│   │
                                                  │   └──
                                                SearchEmailsUseCase.ts\n│   │
                                                ├── services/\n│   │   │   ├──
                                                EmailSyncService.ts\n│   │   │
                                                 └── EmailEventService.ts\n│   │
                                                   └── dtos/\n│   │       ├──
                                                EmailDTO.ts\n│   │       └──
                                                EmailAccountDTO.ts\n│   │\n│
                                                ├── infrastructure/\n│   │   ├──
                                                 providers/\n│   │   │   ├──
                                                GmailProvider.ts      (~400
                                                lines - Gmail API
                                                integration)\n│   │   │   ├──
                                                OutlookProvider.ts    (~400
                                                lines - Graph API)\n│   │   │
                                                └── SmtpProvider.ts       (~300
                                                lines - IMAP/SMTP)\n│   │   ├──
                                                repositories/\n│   │   │   ├──
                                                EmailRepository.ts\n│   │   │
                                                └── EmailAccountRepository.ts\n│
                                                   │   ├── cache/\n│   │   │
                                                └── EmailCacheService.ts\n│   │
                                                  ├── jobs/\n│   │   │   ├──
                                                EmailSyncJob.ts\n│   │   │   └──
                                                 EmailCleanupJob.ts\n│   │   └──
                                                 webhooks/\n│   │       ├──
                                                GmailWebhookHandler.ts\n│   │
                                                    └──
                                                OutlookWebhookHandler.ts\n│
                                                │\n│   ├── presentation/\n│   │
                                                  ├── controllers/\n│   │   │
                                                ├── EmailController.ts\n│   │
                                                │   ├──
                                                EmailAccountController.ts\n│   │
                                                   │   └──
                                                WebhookController.ts\n│   │
                                                ├── routes/\n│   │   │   └──
                                                email.routes.ts\n│   │   └──
                                                validation/\n│   │       └──
                                                email.schemas.ts\n│   │\n│   └──
                                                 index.ts
                                                (EmailModule class)\n│\n├──
                                                module.json
                                                  (manifest)\n├──
                                                package.json\n└──
                                                README.md\n```\n\nThis follows
                                                the exact same pattern as Garden
                                                 module - proven, clean,
                                                maintainable!", thoughtNumber:
                                                8, totalThoughts: 8,
                                                nextThoughtNeeded: false)
  ⎿  {                                                                     
       "thoughtNumber": 8,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ Email Module - Architecture Design

  I've thought through the complete architecture for your email integration
  module. Here's how it fits into your existing clean architecture while
  staying resource-efficient and cost-effective:

  Module Classification

  The Email module is a Shared Infrastructure Module - similar to
  authentication or logging services:

  Core (EventBus, IModule, errors, Result)
    ↑
  Email Module (shared infrastructure)
    ↑
  Domain Modules (Finance, Garden, House Maintenance, etc.)

  Key principle: Other modules depend on Email module, but Email module only
   depends on Core.

  ---
  Architecture Overview

  Core Strategy: Metadata-Only Storage + Lazy Loading

  Store:
  - ✅ Email metadata (from, to, subject, timestamp, snippet, messageId)
  - ✅ Provider message IDs (to fetch full content later)
  - ✅ Flags (isRead, hasAttachments, labels)

  Don't Store:
  - ❌ Full email body
  - ❌ Attachments
  - ❌ HTML content

  Benefit: 250x storage reduction (100MB vs 25GB for 50K emails)

  ---
  Event-Driven Processing Flow

  1. Email arrives at Gmail/Outlook
     ↓
  2. Provider webhook → Email Module (push notification, no polling!)
     ↓
  3. Email Module syncs METADATA ONLY to PostgreSQL
     ↓
  4. Email Module publishes EmailReceived event
     {
       emailId, accountId, from, to, subject,
       snippet, timestamp, hasAttachments, labels
     }
     ↓
  5. Domain modules listen and filter
     Finance: "subject contains 'invoice'?"
     Garden: "from='supplier@garden.com'?"
     ↓
  6. If interested → emailModule.getEmail(emailId)
     ↓
  7. Email Module:
     - Check Redis cache (1-hour TTL)
     - If miss → fetch from provider → cache → return
     ↓
  8. Domain module processes full email

  Efficiency: Only fetch full emails when needed (maybe 5% of all emails)

  ---
  Clean Architecture Layers

  Domain Layer (src/domain/)

  Entities:
  // Email.ts (~300 lines)
  class Email {
    private constructor(
      private _id: string,
      private _accountId: string,
      private _from: EmailAddress,
      private _to: EmailAddress[],
      private _subject: string,
      private _snippet: string,
      private _timestamp: Date,
      private _providerMessageId: string,
      private _threadId: string | null,
      private _hasAttachments: boolean,
      private _labels: string[],
      private _isRead: boolean
    ) {}

    // Rich domain methods
    isFromDomain(domain: string): boolean {
      return this._from.domain === domain;
    }

    containsKeyword(keyword: string): boolean {
      return this._subject.toLowerCase().includes(keyword.toLowerCase()) ||
             this._snippet.toLowerCase().includes(keyword.toLowerCase());
    }

    isOlderThan(days: number): boolean {
      const cutoff = new Date();
      cutoff.setDate(cutoff.getDate() - days);
      return this._timestamp < cutoff;
    }

    hasLabel(label: string): boolean {
      return this._labels.includes(label);
    }
  }

  // EmailAccount.ts (~250 lines)
  class EmailAccount {
    private constructor(
      private _id: string,
      private _userId: string,
      private _provider: EmailProvider,
      private _email: EmailAddress,
      private _isActive: boolean,
      private _lastSyncedAt: Date | null,
      private _credentials: EncryptedCredentials
    ) {}

    needsSync(): boolean {
      if (!this._lastSyncedAt) return true;
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
      return this._lastSyncedAt < fiveMinutesAgo;
    }

    isGmail(): boolean { return this._provider === EmailProvider.GMAIL; }
    isOutlook(): boolean { return this._provider === EmailProvider.OUTLOOK;
  }
    isSmtp(): boolean { return this._provider === EmailProvider.SMTP; }
  }

  Value Objects:
  // EmailAddress.ts (~100 lines)
  class EmailAddress {
    private constructor(
      private readonly _address: string,
      private readonly _name: string | null
    ) {}

    static create(address: string, name?: string): Result<EmailAddress,
  ValidationError> {
      if (!this.isValidEmail(address)) {
        return Result.fail(new ValidationError('Invalid email address', [
          { field: 'address', message: 'Must be valid email format' }
        ]));
      }
      return Result.ok(new EmailAddress(address, name || null));
    }

    get domain(): string {
      return this._address.split('@')[1];
    }

    get localPart(): string {
      return this._address.split('@')[0];
    }

    toString(): string {
      return this._name ? `${this._name} <${this._address}>` :
  this._address;
    }
  }

  // EmailProvider.ts (~50 lines)
  enum EmailProvider {
    GMAIL = 'gmail',
    OUTLOOK = 'outlook',
    SMTP = 'smtp'
  }

  Interfaces:
  // IEmailProvider.ts - Adapter interface for different providers
  interface IEmailProvider {
    // Fetch emails (lazy loading)
    fetchEmail(messageId: string): Promise<Result<EmailContent, BaseError>>;

    // List metadata only
    listEmails(filter: EmailFilter): Promise<Result<EmailMetadata[],
  BaseError>>;

    // Setup webhooks
    setupWebhook(accountId: string, webhookUrl: string):
  Promise<Result<void, BaseError>>;

    // Send emails (future)
    sendEmail(email: OutgoingEmail): Promise<Result<void, BaseError>>;
  }

  // IEmailRepository.ts
  interface IEmailRepository {
    findById(id: string): Promise<Result<Email, BaseError>>;
    findByProviderMessageId(providerId: string): Promise<Result<Email,
  BaseError>>;
    findByAccount(accountId: string, filter: EmailFilter):
  Promise<Result<Email[], BaseError>>;
    create(email: Email): Promise<Result<Email, BaseError>>;
    update(email: Email): Promise<Result<Email, BaseError>>;
    deleteOlderThan(days: number): Promise<Result<number, BaseError>>;
  }

  ---
  Application Layer (src/application/)

  Use Cases:
  // GetEmailUseCase.ts (~120 lines)
  export class GetEmailUseCase {
    constructor(
      private emailRepository: IEmailRepository,
      private emailCache: EmailCacheService,
      private emailProvider: IEmailProvider
    ) {}

    async execute(emailId: string): Promise<Result<EmailWithContent,
  BaseError>> {
      // 1. Get metadata from repository
      const metadataResult = await this.emailRepository.findById(emailId);
      if (metadataResult.isFail()) return Result.fail(metadataResult.error);

      const metadata = metadataResult.value;

      // 2. Check cache for full content
      const cached = await this.emailCache.get(emailId);
      if (cached) {
        return Result.ok({ ...metadata, content: cached });
      }

      // 3. Fetch from provider (lazy loading!)
      const contentResult = await this.emailProvider.fetchEmail(
        metadata.providerMessageId
      );
      if (contentResult.isFail()) return Result.fail(contentResult.error);

      // 4. Cache for 1 hour
      await this.emailCache.set(emailId, contentResult.value, 3600);

      // 5. Return combined result
      return Result.ok({
        ...metadata,
        content: contentResult.value
      });
    }
  }

  // SyncEmailsUseCase.ts (~150 lines)
  export class SyncEmailsUseCase {
    constructor(
      private emailRepository: IEmailRepository,
      private emailAccountRepository: IEmailAccountRepository,
      private emailProvider: IEmailProvider,
      private eventBus: EventBus
    ) {}

    async execute(accountId: string): Promise<Result<number, BaseError>> {
      // 1. Get account
      const accountResult = await
  this.emailAccountRepository.findById(accountId);
      if (accountResult.isFail()) return Result.fail(accountResult.error);

      const account = accountResult.value;

      // 2. Check if sync needed
      if (!account.needsSync()) {
        return Result.ok(0);
      }

      // 3. List email metadata from provider
      const listResult = await this.emailProvider.listEmails({
        since: account.lastSyncedAt
      });
      if (listResult.isFail()) return Result.fail(listResult.error);

      // 4. Store metadata only (NOT full content!)
      let synced = 0;
      for (const metadata of listResult.value) {
        const email = Email.create(metadata);
        await this.emailRepository.create(email);

        // 5. Publish event for each email
        await this.eventBus.publish({
          type: 'EmailReceived',
          source: 'email',
          payload: EmailDTO.fromEntity(email)
        });

        synced++;
      }

      // 6. Update last synced timestamp
      account.updateLastSynced();
      await this.emailAccountRepository.update(account);

      return Result.ok(synced);
    }
  }

  ---
  Infrastructure Layer (src/infrastructure/)

  Providers:
  // GmailProvider.ts (~400 lines)
  export class GmailProvider implements IEmailProvider {
    constructor(private gmail: gmail_v1.Gmail) {}

    async fetchEmail(messageId: string): Promise<Result<EmailContent,
  BaseError>> {
      try {
        const response = await this.gmail.users.messages.get({
          userId: 'me',
          id: messageId,
          format: 'full'
        });

        return Result.ok({
          body: this.extractBody(response.data),
          htmlBody: this.extractHtmlBody(response.data),
          attachments: this.extractAttachments(response.data)
        });
      } catch (error) {
        return Result.fail(new ExternalServiceError('Gmail API failed',
  error));
      }
    }

    async listEmails(filter: EmailFilter): Promise<Result<EmailMetadata[],
  BaseError>> {
      try {
        // Only fetch metadata, not full content!
        const response = await this.gmail.users.messages.list({
          userId: 'me',
          maxResults: filter.limit || 100,
          q: this.buildQuery(filter)
        });

        const metadata = response.data.messages?.map(msg =>
          this.extractMetadata(msg)
        ) || [];

        return Result.ok(metadata);
      } catch (error) {
        return Result.fail(new ExternalServiceError('Gmail API failed',
  error));
      }
    }

    async setupWebhook(accountId: string, webhookUrl: string):
  Promise<Result<void, BaseError>> {
      try {
        // Gmail Cloud Pub/Sub push notifications
        await this.gmail.users.watch({
          userId: 'me',
          requestBody: {
            topicName: 'projects/YOUR_PROJECT/topics/gmail-push',
            labelIds: ['INBOX']
          }
        });
        return Result.ok(undefined);
      } catch (error) {
        return Result.fail(new ExternalServiceError('Failed to setup 
  webhook', error));
      }
    }
  }

  // OutlookProvider.ts (~400 lines)
  export class OutlookProvider implements IEmailProvider {
    constructor(private graphClient: Client) {}

    async fetchEmail(messageId: string): Promise<Result<EmailContent,
  BaseError>> {
      // Similar to Gmail but using Microsoft Graph API
    }

    async listEmails(filter: EmailFilter): Promise<Result<EmailMetadata[],
  BaseError>> {
      // Similar to Gmail but using Graph API
    }

    async setupWebhook(accountId: string, webhookUrl: string):
  Promise<Result<void, BaseError>> {
      // Microsoft Graph webhooks (subscriptions)
      await this.graphClient.api('/subscriptions').post({
        changeType: 'created',
        notificationUrl: webhookUrl,
        resource: '/me/mailFolders/inbox/messages',
        expirationDateTime: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)
  // 3 days
      });
    }
  }

  Cache:
  // EmailCacheService.ts (~150 lines)
  export class EmailCacheService {
    constructor(private redis: Redis) {}

    async get(emailId: string): Promise<EmailContent | null> {
      const cached = await this.redis.get(`email:content:${emailId}`);
      if (!cached) return null;

      // Decompress and parse
      const decompressed = await decompress(cached);
      return JSON.parse(decompressed);
    }

    async set(emailId: string, content: EmailContent, ttl: number):
  Promise<void> {
      // Compress to save Redis memory
      const compressed = await compress(JSON.stringify(content));
      await this.redis.setex(`email:content:${emailId}`, ttl, compressed);
    }
  }

  Jobs:
  // EmailSyncJob.ts (~100 lines)
  export class EmailSyncJob {
    async execute(accountId: string): Promise<void> {
      const useCase = new SyncEmailsUseCase(/*...*/);
      await useCase.execute(accountId);
    }
  }

  // EmailCleanupJob.ts (~80 lines)
  export class EmailCleanupJob {
    async execute(): Promise<void> {
      // Delete metadata older than 90 days
      await emailRepository.deleteOlderThan(90);

      // Clear expired cache entries (Redis handles this automatically with 
  TTL)
    }
  }

  ---
  Presentation Layer (src/presentation/)

  Controllers:
  // EmailController.ts (~200 lines)
  export class EmailController {
    async getEmail(req: Request, res: Response, next: NextFunction):
  Promise<void> {
      const { id } = req.params;

      const useCase = new GetEmailUseCase(
        emailRepository,
        emailCache,
        emailProviderFactory.create(accountId)
      );

      const result = await useCase.execute(id);

      if (result.isFail()) {
        next(result.error);
        return;
      }

      res.json(EmailDTO.toResponseDTO(result.value));
    }

    async searchEmails(req: Request, res: Response, next: NextFunction):
  Promise<void> {
      const filter = EmailFilterSchema.parse(req.query);

      const useCase = new SearchEmailsUseCase(emailRepository);
      const result = await useCase.execute(filter);

      if (result.isFail()) {
        next(result.error);
        return;
      }

      res.json(result.value.map(EmailDTO.toResponseDTO));
    }
  }

  // WebhookController.ts (~150 lines)
  export class WebhookController {
    async handleGmailWebhook(req: Request, res: Response): Promise<void> {
      // Gmail sends Pub/Sub message
      const message = req.body.message;
      const accountId = this.extractAccountId(message);

      // Trigger sync job
      await emailSyncQueue.add('sync-emails', { accountId });

      res.status(200).send('OK');
    }

    async handleOutlookWebhook(req: Request, res: Response): Promise<void> {
      // Outlook sends subscription notification
      const notification = req.body.value[0];
      const accountId = notification.subscriptionId;

      // Trigger sync job
      await emailSyncQueue.add('sync-emails', { accountId });

      res.status(202).send('Accepted');
    }
  }

  Routes:
  // email.routes.ts
  const router = express.Router();

  // Email operations
  router.get('/emails/:id', emailController.getEmail);
  router.get('/emails', emailController.searchEmails);

  // Account management
  router.post('/accounts', emailAccountController.connect);
  router.get('/accounts', emailAccountController.list);
  router.delete('/accounts/:id', emailAccountController.disconnect);

  // Webhooks
  router.post('/webhooks/gmail', webhookController.handleGmailWebhook);
  router.post('/webhooks/outlook', webhookController.handleOutlookWebhook);

  export default router;

  ---
  How Other Modules Use Email Module

  1. Event-Driven Pattern (Recommended)

  // Finance module listening for invoice emails
  export class FinanceModule implements IModule {
    async initialize(context: ModuleContext): Promise<void> {
      // Subscribe to email events
      context.eventBus.subscribe('EmailReceived', async (event) => {
        const email = event.payload;

        // Filter: Is this an invoice?
        if (this.isInvoiceEmail(email)) {
          // Fetch full content
          const fullEmail = await context.emailModule.getEmail(email.id);

          // Process invoice
          await this.processInvoice(fullEmail);
        }
      });
    }

    private isInvoiceEmail(email: EmailDTO): boolean {
      return email.subject.toLowerCase().includes('invoice') ||
             email.subject.toLowerCase().includes('factuur') ||
             email.from.includes('invoices@') ||
             email.hasAttachments; // Likely PDF invoice
    }
  }

  2. Query Pattern (On-Demand)

  // Garden module checking for supplier emails
  export class GardenModule {
    async checkSupplierUpdates(): Promise<void> {
      // Search for specific emails
      const emails = await emailModule.searchEmails({
        from: 'supplier@garden-shop.com',
        since: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 
  days
        hasAttachments: true
      });

      for (const email of emails) {
        // Fetch full content only for matching emails
        const fullEmail = await emailModule.getEmail(email.id);
        await this.processSupplierUpdate(fullEmail);
      }
    }
  }

  ---
  Database Schema

  // email_accounts table
  model EmailAccount {
    id              String        @id @default(uuid())
    userId          String
    provider        EmailProvider
    email           String
    isActive        Boolean       @default(true)
    lastSyncedAt    DateTime?
    credentials     Json          // Encrypted OAuth tokens or SMTP password
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt
    
    emails          Email[]
    
    @@index([userId])
    @@index([provider])
  }

  // emails table (METADATA ONLY!)
  model Email {
    id                  String       @id @default(uuid())
    accountId           String
    providerMessageId   String       // Gmail/Outlook message ID for lazy 
  loading
    
    // Metadata fields
    from                String
    fromName            String?
    to                  String[]
    cc                  String[]
    subject             String
    snippet             String       // First 200 chars
    timestamp           DateTime
    
    // Flags
    threadId            String?
    hasAttachments      Boolean      @default(false)
    attachmentCount     Int          @default(0)
    labels              String[]
    isRead              Boolean      @default(false)
    isStarred           Boolean      @default(false)
    sizeBytes           Int?
    
    createdAt           DateTime     @default(now())
    updatedAt           DateTime     @updatedAt
    
    account             EmailAccount @relation(fields: [accountId], 
  references: [id], onDelete: Cascade)
    
    @@index([accountId])
    @@index([providerMessageId])
    @@index([timestamp])
    @@index([from])
    @@index([labels])
    @@unique([accountId, providerMessageId])
  }

  enum EmailProvider {
    GMAIL
    OUTLOOK
    SMTP
  }

  Storage estimate:
  - Metadata per email: ~200 bytes
  - 50,000 emails: ~10 MB
  - vs Full storage: ~25 GB
  - Reduction: 2,500x

  ---
  Cost Optimization Summary

  1. Push Notifications (No Polling)

  - Gmail: Cloud Pub/Sub webhooks (free)
  - Outlook: Graph API subscriptions (free)
  - SMTP: IMAP IDLE (no extra cost)
  - Benefit: Near real-time, zero API quota waste

  2. Lazy Loading

  - Only fetch ~5% of emails (the ones modules actually need)
  - API calls saved: 95%
  - Bandwidth saved: 95%

  3. Smart Caching

  - Redis cache with 1-hour TTL
  - Compressed email content
  - LRU eviction
  - Cache hit rate: ~70-80% (estimated)

  4. Retention Policy

  - Metadata: Keep 90 days (configurable)
  - Full content: Never stored, always fetched on-demand
  - Auto-cleanup job runs daily

  5. Batch Processing

  - Queue email processing with BullMQ
  - Rate limiting prevents quota exhaustion
  - Retries with exponential backoff

  Cost Comparison (50K emails/year):

  | Approach                | Storage | API Calls           | Monthly Cost |
  |-------------------------|---------|---------------------|--------------|
  | Full storage            | 25 GB   | High (polling)      | ~$5-10       |
  | Metadata + lazy loading | 10 MB   | Very low (webhooks) | ~$0.01       |
  | Savings                 | 2,500x  | ~95%                | ~500x        |

  ---
  Module Manifest

  {
    "name": "email",
    "version": "1.0.0",
    "description": "Email integration for Gmail, Outlook, and SMTP",
    "author": "LifeOS",
    "type": "infrastructure",
    "permissions": [
      "core.events.publish",
      "core.events.subscribe"
    ],
    "dependencies": {
      "core": "^1.0.0"
    },
    "events": {
      "subscribes": [],
      "publishes": [
        "EmailReceived",
        "EmailSent",
        "EmailAccountConnected",
        "EmailAccountDisconnected"
      ]
    },
    "provides": {
      "services": [
        "getEmail",
        "searchEmails",
        "sendEmail"
      ]
    }
  }

  ---
  Implementation Phases

  Phase 1: Core Infrastructure (Week 1-2)

  - Email domain entities (Email, EmailAccount, EmailAddress)
  - Repository interfaces
  - IEmailProvider interface
  - Database schema + migrations

  Phase 2: Gmail Integration (Week 3)

  - GmailProvider implementation
  - OAuth 2.0 flow for account connection
  - Webhook handler for push notifications
  - Metadata sync use case

  Phase 3: Caching & Lazy Loading (Week 4)

  - EmailCacheService (Redis)
  - GetEmailUseCase with cache-aside pattern
  - Background sync jobs (BullMQ)

  Phase 4: Outlook Integration (Week 5)

  - OutlookProvider implementation
  - Microsoft Graph OAuth flow
  - Webhook handler

  Phase 5: SMTP/IMAP (Week 6)

  - SmtpProvider implementation
  - IMAP IDLE for push-like notifications
  - Fallback polling mechanism

  Phase 6: Module Integration (Week 7)

  - Event publishing to EventBus
  - Public API for other modules
  - Finance module integration example
  - Documentation

  ---
  Testing Strategy

  // Unit tests
  describe('Email entity', () => {
    it('should filter by domain', () => {
      const email = createTestEmail({ from: 'test@gmail.com' });
      expect(email.isFromDomain('gmail.com')).toBe(true);
    });
  });

  // Integration tests
  describe('GetEmailUseCase', () => {
    it('should fetch from cache if available', async () => {
      // Mock cache hit
      cacheService.get.mockResolvedValue(mockContent);

      const result = await useCase.execute('email-id');

      expect(result.isOk()).toBe(true);
      expect(emailProvider.fetchEmail).not.toHaveBeenCalled(); // No API 
  call!
    });

    it('should fetch from provider if cache miss', async () => {
      // Mock cache miss
      cacheService.get.mockResolvedValue(null);
      emailProvider.fetchEmail.mockResolvedValue(Result.ok(mockContent));

      const result = await useCase.execute('email-id');

      expect(result.isOk()).toBe(true);
      expect(emailProvider.fetchEmail).toHaveBeenCalledOnce();
      expect(cacheService.set).toHaveBeenCalled(); // Cache populated
    });
  });

  // E2E tests (Playwright)
  test('Finance module processes invoice email', async () => {
    // 1. Simulate webhook from Gmail
    await request.post('/api/email/webhooks/gmail', { /* payload */ });

    // 2. Wait for event processing
    await waitForEvent('EmailReceived');

    // 3. Verify Finance module created invoice
    const invoice = await db.invoice.findFirst({ where: { sourceEmail:
  emailId }});
    expect(invoice).toBeDefined();
  });

  ---
  Summary

  This architecture provides:

  ✅ Clean Architecture - Clear separation of concerns✅ Event-Driven -
  Loose coupling between modules✅ Cost-Effective - 2,500x storage
  reduction, 95% fewer API calls✅ Scalable - Push notifications, lazy
  loading, caching✅ Extensible - Easy to add new providers✅ Testable -
  Repository pattern, dependency injection✅ Maintainable - Small files,
  SOLID principles

  Next step: Should I create the initial file structure and start
  implementing Phase 1 (core infrastructure)?

> i would do it in a other way if an email is comming in we look at the mail
 and with AI we ask a module if they are interested if they are they need to
 handle the email savinf or something else 

⏺ Ah, this is a much smarter approach! Let me redesign the architecture with
   AI-powered intelligent routing instead of storing metadata for
  everything.

  AI-Powered Email Routing Architecture

  Core Flow:

  1. Email arrives (webhook from Gmail/Outlook)
     ↓
  2. Email Module extracts basic context (from, to, subject, snippet)
     ↓
  3. AI analyzes email context + asks each module: "Are you interested?"
     Module describes capabilities via natural language
     ↓
  4. AI determines which module(s) should handle this email
     ↓
  5. Only interested modules receive the email
     ↓
  6. Module extracts what it needs and stores in its own tables
     ↓
  7. Email Module never stores anything (just routes)

  Benefits:
  - ✅ Zero storage in Email Module (just routing)
  - ✅ AI-powered intelligence instead of keyword matching
  - ✅ Modules decide what to store (extracted data, not raw emails)
  - ✅ No irrelevant emails processed
  - ✅ Self-describing modules via natural language

  ---

⏺ Revised Architecture: AI-Powered Email Router

  1. Module Email Handler Interface

  Each module that wants to receive emails implements this:

  // packages/core/src/module-system/IEmailHandler.ts
  interface IEmailHandler {
    /**
     * Natural language description of what emails this module handles
     * Used by AI to determine if email is relevant
     */
    getEmailInterest(): EmailInterestDescription;

    /**
     * Check if module can handle this email (AI pre-filtered)
     * This is a final validation before processing
     */
    canHandle(context: EmailContext): Promise<boolean>;

    /**
     * Process the email - module decides what to extract and store
     */
    handleEmail(email: EmailContent): Promise<Result<void, BaseError>>;
  }

  interface EmailInterestDescription {
    moduleName: string;
    description: string; // Natural language description
    examples: string[];  // Example emails this module would handle
    keywords?: string[]; // Optional: high-confidence keywords
  }

  interface EmailContext {
    from: EmailAddress;
    to: EmailAddress[];
    subject: string;
    snippet: string;      // First 200 chars
    hasAttachments: boolean;
    timestamp: Date;
  }

  2. Example Module Implementations

  Finance Module:
  export class FinanceModule implements IModule, IEmailHandler {
    getEmailInterest(): EmailInterestDescription {
      return {
        moduleName: 'finance',
        description: `
          I handle financial emails including:
          - Invoices and receipts (with PDF attachments)
          - Bank statements and transaction notifications
          - Payment confirmations (PayPal, Stripe, etc.)
          - Subscription renewals and billing notices
          - Tax documents and financial reports
          - Expense reimbursement emails
        `,
        examples: [
          'Invoice #12345 from Acme Corp',
          'Your PayPal payment to Garden Supplies was successful',
          'Monthly bank statement for April 2025',
          'Subscription renewal: Netflix - $15.99'
        ],
        keywords: ['invoice', 'factuur', 'receipt', 'payment', 'betaling']
      };
    }

    async canHandle(context: EmailContext): Promise<boolean> {
      // AI already filtered, this is final validation
      // Check if from known financial senders
      const financialDomains = ['paypal.com', 'stripe.com', 'bank.com'];
      return financialDomains.some(domain =>
        context.from.address.includes(domain)
      ) || context.hasAttachments; // Likely PDF invoice
    }

    async handleEmail(email: EmailContent): Promise<Result<void, BaseError>>
   {
      // Extract what we need using AI
      const extracted = await this.aiExtractor.extractInvoiceData(email);

      if (extracted.isInvoice) {
        // Store ONLY extracted data in our own tables
        await this.invoiceRepository.create({
          vendor: extracted.vendor,
          amount: Money.create(extracted.amount, extracted.currency),
          invoiceNumber: extracted.invoiceNumber,
          dueDate: extracted.dueDate,
          // Store reference to original email (provider message ID)
          sourceEmailId: email.providerMessageId,
          sourceEmailProvider: email.provider
        });

        // Publish event
        await this.eventBus.publish({
          type: 'InvoiceReceived',
          source: 'finance',
          payload: { invoiceId: invoice.id }
        });
      }

      return Result.ok(undefined);
    }
  }

  Garden Module:
  export class GardenModule implements IModule, IEmailHandler {
    getEmailInterest(): EmailInterestDescription {
      return {
        moduleName: 'garden',
        description: `
          I handle garden-related emails including:
          - Order confirmations from garden suppliers
          - Plant care tips and newsletters
          - Delivery notifications for seeds, tools, fertilizer
          - Garden service reminders (lawn care, tree trimming)
          - Seasonal planting guides
        `,
        examples: [
          'Your order of tomato seeds has shipped',
          'Spring planting guide for your region',
          'Lawn care appointment confirmed for May 15'
        ],
        keywords: ['garden', 'plant', 'seed', 'fertilizer', 'lawn']
      };
    }

    async canHandle(context: EmailContext): Promise<boolean> {
      // Check if from known garden suppliers
      const gardenSuppliers = ['gardensupply.com', 'seedcompany.com'];
      return gardenSuppliers.some(supplier =>
        context.from.address.includes(supplier)
      );
    }

    async handleEmail(email: EmailContent): Promise<Result<void, BaseError>>
   {
      // AI extracts order details
      const extracted = await this.aiExtractor.extractOrderData(email);

      if (extracted.isOrder) {
        // Create tasks for received items
        for (const item of extracted.items) {
          await this.taskRepository.create({
            title: `Plant ${item.name}`,
            description: `Received from ${extracted.supplier}`,
            type: 'planting',
            dueDate: this.calculatePlantingDate(item.plantingWindow)
          });
        }

        // Store only what we need (no raw email!)
        await this.orderRepository.create({
          supplier: extracted.supplier,
          items: extracted.items,
          deliveryDate: extracted.deliveryDate,
          sourceEmailId: email.providerMessageId
        });
      }

      return Result.ok(undefined);
    }
  }

  ---
  3. AI Router Service

⏺ // packages/modules/email/src/application/services/EmailRouterService.ts
  export class EmailRouterService {
    constructor(
      private moduleRegistry: ModuleRegistry,
      private aiClient: AIClient, // MCP or direct OpenAI/Anthropic
      private eventBus: EventBus
    ) {}

    async routeEmail(context: EmailContext): Promise<Result<void,
  BaseError>> {
      // 1. Get all modules that implement IEmailHandler
      const emailHandlers = this.moduleRegistry
        .getAll()
        .filter(m => this.implementsEmailHandler(m));

      if (emailHandlers.length === 0) {
        // No modules interested in emails, skip
        return Result.ok(undefined);
      }

      // 2. Build AI prompt with module descriptions
      const prompt = this.buildRoutingPrompt(context, emailHandlers);

      // 3. Ask AI which modules should handle this email
      const aiResponse = await this.aiClient.complete({
        prompt,
        temperature: 0.1, // Low temperature for consistent routing
        maxTokens: 500
      });

      // 4. Parse AI response (returns module names)
      const selectedModules = this.parseAIResponse(aiResponse);

      if (selectedModules.length === 0) {
        // No modules interested, email ignored (not stored!)
        await this.eventBus.publish({
          type: 'EmailIgnored',
          source: 'email',
          payload: { reason: 'No interested modules', context }
        });
        return Result.ok(undefined);
      }

      // 5. Fetch full email content (lazy loading!)
      const emailResult = await this.emailProvider.fetchEmail(
        context.providerMessageId
      );
      if (emailResult.isFail()) return Result.fail(emailResult.error);

      const email = emailResult.value;

      // 6. Let selected modules handle the email
      for (const moduleName of selectedModules) {
        const module = emailHandlers.find(m => m.name === moduleName);
        if (!module) continue;

        const handler = module as IEmailHandler;

        // Final validation by module itself
        const canHandle = await handler.canHandle(context);
        if (!canHandle) continue;

        // Module processes email and stores what it needs
        const result = await handler.handleEmail(email);

        if (result.isFail()) {
          // Log error but continue to other modules
          console.error(`Module ${moduleName} failed to handle email:`,
  result.error);
        }
      }

      return Result.ok(undefined);
    }

    private buildRoutingPrompt(
      context: EmailContext,
      handlers: IEmailHandler[]
    ): string {
      const moduleDescriptions = handlers.map(h => {
        const interest = h.getEmailInterest();
        return `
  ## ${interest.moduleName}
  ${interest.description}

  Examples:
  ${interest.examples.map(ex => `- ${ex}`).join('\n')}

  Keywords: ${interest.keywords?.join(', ') || 'None'}
  `;
      }).join('\n---\n');

      return `
  You are an email routing assistant. Analyze the email below and determine 
  which module(s) should handle it.

  # Email Context
  From: ${context.from.toString()}
  To: ${context.to.map(t => t.toString()).join(', ')}
  Subject: ${context.subject}
  Preview: ${context.snippet}
  Has Attachments: ${context.hasAttachments}

  # Available Modules
  ${moduleDescriptions}

  # Task
  Determine which module(s) should handle this email. Consider:
  1. Does the email content match the module's description?
  2. Would the module find value in processing this email?
  3. Multiple modules can handle the same email if relevant to both

  Respond with ONLY a JSON array of module names, or empty array if no 
  modules match:
  ["finance", "garden"] or []

  Response:`;
    }

    private parseAIResponse(response: string): string[] {
      try {
        // Extract JSON from response
        const jsonMatch = response.match(/\[.*\]/s);
        if (!jsonMatch) return [];

        const modules = JSON.parse(jsonMatch[0]);
        return Array.isArray(modules) ? modules : [];
      } catch (error) {
        console.error('Failed to parse AI routing response:', error);
        return [];
      }
    }
  }

  ---
  4. Email Module Architecture (Revised)

⏺ Email Module is now a thin routing layer with NO storage:

  packages/modules/email/
  ├── src/
  │   ├── domain/
  │   │   ├── value-objects/
  │   │   │   ├── EmailAddress.ts       (shared value object)
  │   │   │   ├── EmailProvider.ts      (enum: Gmail, Outlook, SMTP)
  │   │   │   └── EmailContext.ts       (lightweight email preview)
  │   │   └── interfaces/
  │   │       └── IEmailProvider.ts     (adapter for Gmail/Outlook/SMTP)
  │   │
  │   ├── application/
  │   │   ├── services/
  │   │   │   ├── EmailRouterService.ts    (AI-powered routing)
  │   │   │   └── EmailAccountService.ts   (manage connections)
  │   │   └── use-cases/
  │   │       ├── RouteEmailUseCase.ts
  │   │       └── ConnectAccountUseCase.ts
  │   │
  │   ├── infrastructure/
  │   │   ├── providers/
  │   │   │   ├── GmailProvider.ts      (fetch emails on-demand)
  │   │   │   ├── OutlookProvider.ts
  │   │   │   └── SmtpProvider.ts
  │   │   ├── ai/
  │   │   │   └── EmailRoutingAIClient.ts  (LLM integration)
  │   │   ├── cache/
  │   │   │   └── EmailCacheService.ts  (temporary cache for routing)
  │   │   └── webhooks/
  │   │       ├── GmailWebhookHandler.ts
  │   │       └── OutlookWebhookHandler.ts
  │   │
  │   ├── presentation/
  │   │   ├── controllers/
  │   │   │   ├── WebhookController.ts  (receive email notifications)
  │   │   │   └── AccountController.ts  (connect/disconnect accounts)
  │   │   └── routes/
  │   │       └── email.routes.ts
  │   │
  │   └── index.ts                      (EmailModule - no storage!)
  │
  └── module.json

  Key difference: No repositories, no database tables! Just routing.

  ---
  5. Complete Flow Diagram

  ┌─────────────────────────────────────────────────────────────────┐
  │                    Email Arrives at Provider                     │
  │                  (Gmail / Outlook / SMTP Server)                 │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  │ Webhook notification
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │              Email Module - WebhookController                    │
  │  • Receives webhook from Gmail/Outlook                          │
  │  • Extracts EmailContext (from, to, subject, snippet)           │
  │  • NO storage, just trigger routing                             │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │                  EmailRouterService                              │
  │  1. Get all modules implementing IEmailHandler                  │
  │  2. Build AI prompt with:                                       │
  │     • Email context                                             │
  │     • Module descriptions (natural language)                    │
  │     • Module examples                                           │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │                    AI Analysis (LLM)                             │
  │  Prompt:                                                         │
  │  "This email is about: [subject]                                │
  │   From: [sender]                                                │
  │                                                                  │
  │   Available modules:                                            │
  │   - Finance: handles invoices, payments...                      │
  │   - Garden: handles plant orders, suppliers...                  │
  │                                                                  │
  │   Which modules should process this email?"                     │
  │                                                                  │
  │  Response: ["finance"] or ["garden"] or ["finance", "garden"]   │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
                      ┌───────────────────────┐
                      │ Modules selected by AI │
                      └───────────┬───────────┘
                                  │
                  ┌───────────────┴───────────────┐
                  │                               │
                  ▼                               ▼
  ┌───────────────────────────┐   ┌───────────────────────────┐
  │   Finance Module          │   │   Garden Module           │
  │   canHandle(context)?     │   │   canHandle(context)?     │
  │   ✓ Yes                   │   │   ✗ No (skip)            │
  └───────────┬───────────────┘   └───────────────────────────┘
              │
              │ Request full email
              ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │            Email Module - EmailProvider                          │
  │  • Fetch full email from Gmail/Outlook API                      │
  │  • Cache for 1 hour (if other modules need it)                  │
  │  • Return full EmailContent                                     │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │         Finance Module - handleEmail(email)                      │
  │  1. AI extracts invoice data:                                   │
  │     • Vendor: "Acme Corp"                                       │
  │     • Amount: €125.50                                           │
  │     • Due date: 2025-11-15                                      │
  │  2. Stores ONLY extracted data in finance_invoices table        │
  │  3. Stores reference: sourceEmailId (for re-fetching if needed) │
  │  4. Publishes InvoiceReceived event                             │
  │  5. Original email NOT stored anywhere!                         │
  └─────────────────────────────────────────────────────────────────┘

  ---
  6. Database Schema (Minimal)

  Email Module Tables:
  // ONLY email accounts, NO email storage!
  model EmailAccount {
    id              String        @id @default(uuid())
    userId          String
    provider        EmailProvider
    email           String
    isActive        Boolean       @default(true)
    credentials     Json          // Encrypted tokens
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt

    @@index([userId])
  }

  enum EmailProvider {
    GMAIL
    OUTLOOK
    SMTP
  }

  Finance Module Tables (example):
  // Finance module stores EXTRACTED data, not raw emails
  model Invoice {
    id                  String   @id @default(uuid())
    vendor              String
    amount              Decimal
    currency            String
    invoiceNumber       String?
    dueDate             DateTime?

    // Reference to original email (for re-fetching if needed)
    sourceEmailId       String?  // Provider message ID
    sourceEmailProvider String?  // "gmail" | "outlook"

    createdAt           DateTime @default(now())
  }

  Garden Module Tables (example):
  // Garden module stores order details, not emails
  model GardenOrder {
    id              String   @id @default(uuid())
    supplier        String
    items           Json     // Array of {name, quantity, plantingWindow}
    deliveryDate    DateTime

    // Reference to source email
    sourceEmailId   String?

    createdAt       DateTime @default(now())
  }

  ---
  7. Cost & Efficiency Analysis

  Old approach (metadata storage):
  - Store metadata for EVERY email: 200 bytes × 50K emails = 10 MB
  - Fetch full email when modules request: ~5% of emails

  New approach (AI routing, zero storage):
  - Store NO emails in Email Module: 0 MB
  - AI routing per email: ~500 tokens × $0.000001 = $0.0005/email
  - Fetch full email only for interested modules: ~5% of emails
  - Modules store only extracted data: ~50 bytes × 2,500 emails = 125 KB

  Cost Comparison (50K emails/year):
  | Item                   | Old Approach | New Approach | Savings
            |
  |------------------------|--------------|--------------|------------------
  ----------|
  | Email storage          | 10 MB        | 0 MB         | 100%
            |
  | AI routing             | $0           | $25/year     | -$25
            |
  | Extracted data storage | N/A          | 125 KB       | Much smaller
            |
  | Total cost             | $0.10        | $25          | Worth it for
  intelligence! |
  | Total storage          | 10 MB        | 125 KB       | 98.8% reduction
            |

  The $25/year AI cost is worth it because:
  - ✅ Zero manual configuration (no keyword rules)
  - ✅ Adapts to new email types automatically
  - ✅ Natural language module descriptions
  - ✅ Handles edge cases intelligently
  - ✅ No false positives wasting module time

  ---
  8. Advanced Features

⏺ AI Learning from Module Feedback:

  // Modules can provide feedback to improve routing
  interface IEmailHandler {
    // ... existing methods ...

    /**
     * Module reports if AI routing was correct
     * Used to fine-tune future routing decisions
     */
    provideFeedback(
      emailId: string,
      wasRelevant: boolean,
      reason?: string
    ): Promise<void>;
  }

  // Email Router learns from feedback
  export class EmailRouterService {
    async routeEmail(context: EmailContext): Promise<Result<void,
  BaseError>> {
      // ... existing routing logic ...

      // Track routing decisions for learning
      await this.routingLog.create({
        emailContext: context,
        selectedModules,
        timestamp: new Date()
      });
    }

    async improveRouting(): Promise<void> {
      // Weekly job: analyze feedback and adjust prompts
      const feedback = await this.feedbackRepository.getRecentFeedback();

      if (feedback.falsePositives.length > 10) {
        // Update module descriptions or AI prompt
        await this.adjustRoutingPrompt(feedback);
      }
    }
  }

  Smart Caching Strategy:

  // Cache AI routing decisions for similar emails
  export class EmailRouterService {
    async routeEmail(context: EmailContext): Promise<Result<void,
  BaseError>> {
      // 1. Check if we've seen similar email before
      const cacheKey = this.generateCacheKey(context);
      const cached = await this.cache.get(`routing:${cacheKey}`);

      if (cached) {
        // Reuse previous AI decision (saves LLM call!)
        return this.routeToModules(cached.modules, context);
      }

      // 2. Ask AI (cache miss)
      const selectedModules = await this.askAI(context);

      // 3. Cache decision for 7 days
      await this.cache.set(`routing:${cacheKey}`, { modules: selectedModules
   }, 604800);

      return this.routeToModules(selectedModules, context);
    }

    private generateCacheKey(context: EmailContext): string {
      // Hash based on sender domain + subject keywords
      const domain = context.from.domain;
      const keywords = this.extractKeywords(context.subject);
      return `${domain}:${keywords.join('-')}`;
    }
  }

  Batch Processing for Cost Optimization:

  // Process multiple emails in one AI call
  export class EmailRouterService {
    private emailQueue: EmailContext[] = [];

    async queueEmail(context: EmailContext): Promise<void> {
      this.emailQueue.push(context);

      // Batch every 10 emails or every 30 seconds
      if (this.emailQueue.length >= 10) {
        await this.processBatch();
      }
    }

    private async processBatch(): Promise<void> {
      const batch = this.emailQueue.splice(0, 10);

      // Single AI call for all 10 emails
      const prompt = this.buildBatchRoutingPrompt(batch);
      const response = await this.aiClient.complete({ prompt });

      // Parse response: {email1: ["finance"], email2: ["garden"], ...}
      const routingDecisions = this.parseBatchResponse(response);

      // Route each email to selected modules
      for (let i = 0; i < batch.length; i++) {
        await this.routeToModules(routingDecisions[i], batch[i]);
      }
    }
  }

  ---
  9. Module Examples with AI Extraction

  Finance Module with AI Data Extraction:

  export class FinanceModule implements IEmailHandler {
    async handleEmail(email: EmailContent): Promise<Result<void, BaseError>>
   {
      // Use AI to extract structured data from unstructured email
      const extractionPrompt = `
  Extract invoice details from this email:

  ${email.body}

  Return JSON:
  {
    "isInvoice": boolean,
    "vendor": string,
    "amount": number,
    "currency": string,
    "invoiceNumber": string,
    "dueDate": "YYYY-MM-DD",
    "lineItems": [{"description": string, "amount": number}]
  }
  `;

      const extracted = await this.aiClient.complete({
        prompt: extractionPrompt,
        temperature: 0,
        responseFormat: 'json'
      });

      const invoiceData = JSON.parse(extracted);

      if (!invoiceData.isInvoice) {
        // AI determined this isn't actually an invoice
        return Result.ok(undefined);
      }

      // Store ONLY extracted structured data
      const invoice = await this.invoiceRepository.create({
        vendor: invoiceData.vendor,
        amount: Money.create(invoiceData.amount, invoiceData.currency),
        invoiceNumber: invoiceData.invoiceNumber,
        dueDate: new Date(invoiceData.dueDate),
        lineItems: invoiceData.lineItems,

        // Store reference to fetch original if needed
        sourceEmailId: email.providerMessageId,
        sourceEmailProvider: email.provider,

        // Store extraction for audit trail
        aiExtraction: invoiceData
      });

      // Create task for payment
      await this.taskRepository.create({
        title: `Pay invoice ${invoiceData.invoiceNumber}`,
        description: `${invoiceData.vendor} - ${invoiceData.amount} 
  ${invoiceData.currency}`,
        dueDate: invoiceData.dueDate,
        type: 'payment',
        metadata: { invoiceId: invoice.id }
      });

      return Result.ok(undefined);
    }
  }

  House Maintenance Module Example:

  export class HouseMaintenanceModule implements IEmailHandler {
    getEmailInterest(): EmailInterestDescription {
      return {
        moduleName: 'house-maintenance',
        description: `
          I handle home maintenance and service emails:
          - Appointment confirmations (plumber, electrician, HVAC)
          - Service reminders (furnace inspection, gutter cleaning)
          - Warranty information and manuals
          - Home insurance correspondence
          - Utility bills and statements
          - HOA notices and announcements
        `,
        examples: [
          'Your furnace inspection is scheduled for June 10',
          'Monthly water bill - $45.32',
          'HOA: Roof replacement project update'
        ]
      };
    }

    async handleEmail(email: EmailContent): Promise<Result<void, BaseError>>
   {
      // AI determines type and extracts data
      const extraction = await this.aiClient.complete({
        prompt: `
  Analyze this home maintenance email and extract:

  ${email.body}

  Return JSON:
  {
    "type": "appointment" | "bill" | "reminder" | "warranty" | "notice",
    "servicePro": string (if appointment),
    "date": "YYYY-MM-DD" (if appointment/due date),
    "amount": number (if bill),
    "description": string,
    "actionRequired": boolean
  }
  `
      });

      const data = JSON.parse(extraction);

      switch (data.type) {
        case 'appointment':
          // Create calendar event
          await this.calendarService.createEvent({
            title: `${data.servicePro} - ${data.description}`,
            date: data.date,
            sourceEmailId: email.providerMessageId
          });
          break;

        case 'bill':
          // Create payment task
          await this.taskRepository.create({
            title: `Pay ${data.description}`,
            dueDate: data.date,
            metadata: { amount: data.amount }
          });
          break;

        case 'reminder':
          // Create maintenance task
          await this.maintenanceRepository.create({
            description: data.description,
            dueDate: data.date,
            sourceEmailId: email.providerMessageId
          });
          break;
      }

      return Result.ok(undefined);
    }
  }

  ---
  10. Updated Module System Interface

  Add to Core module system:

  // packages/core/src/module-system/IModule.ts
  interface IModule {
    // ... existing properties ...

    /**
     * Optional: Implement to receive emails
     */
    emailHandler?: IEmailHandler;
  }

  // packages/core/src/module-system/IEmailHandler.ts
  interface IEmailHandler {
    /**
     * Describe what emails this module handles (for AI routing)
     */
    getEmailInterest(): EmailInterestDescription;

    /**
     * Final validation before processing (after AI pre-filter)
     */
    canHandle(context: EmailContext): Promise<boolean>;

    /**
     * Process email - extract data and store what you need
     * Module is responsible for:
     * 1. AI extraction of structured data
     * 2. Storing extracted data in its own tables
     * 3. Creating tasks/events as needed
     * 4. Optionally storing reference to original email
     */
    handleEmail(email: EmailContent): Promise<Result<void, BaseError>>;

    /**
     * Optional: Provide feedback to improve AI routing
     */
    provideFeedback?(
      emailId: string,
      wasRelevant: boolean,
      reason?: string
    ): Promise<void>;
  }

  interface EmailInterestDescription {
    moduleName: string;
    description: string;  // Natural language (used by AI)
    examples: string[];   // Example email subjects/content
    keywords?: string[];  // Optional high-confidence keywords
    senderDomains?: string[]; // Optional known sender domains
  }

  interface EmailContext {
    providerMessageId: string;
    from: EmailAddress;
    to: EmailAddress[];
    subject: string;
    snippet: string;
    hasAttachments: boolean;
    timestamp: Date;
    labels?: string[];
  }

  interface EmailContent extends EmailContext {
    body: string;
    htmlBody?: string;
    attachments: EmailAttachment[];
    provider: EmailProvider;
  }

  ---
  11. Implementation Phases (Revised)

⏺ Phase 1: Core Email Infrastructure (Week 1)

  - Add IEmailHandler interface to Core
  - EmailContext and EmailContent value objects
  - EmailAddress value object
  - IEmailProvider interface (adapter pattern)
  - Email account database schema (only accounts, NO emails)

  Phase 2: Provider Integration (Week 2)

  - GmailProvider implementation (OAuth + fetch API)
  - Gmail webhook handler (Cloud Pub/Sub)
  - Account connection use case
  - Test email fetching on-demand

  Phase 3: AI Routing System (Week 3)

  - EmailRouterService with AI integration
  - AI prompt builder for module selection
  - RouteEmailUseCase
  - Routing cache (Redis) for similar emails
  - Test AI routing with mock modules

  Phase 4: Module Integration (Week 4)

  - Update Finance module to implement IEmailHandler
  - AI extraction for invoice data
  - Store extracted data (not raw emails)
  - Test end-to-end flow: email → AI routing → Finance extraction

  Phase 5: Additional Providers (Week 5)

  - OutlookProvider (Microsoft Graph)
  - Outlook webhook handler
  - SmtpProvider (IMAP IDLE)
  - Test all three providers

  Phase 6: Optimization & Learning (Week 6)

  - Batch processing for multiple emails
  - Feedback system for routing improvement
  - Routing analytics dashboard
  - Cost monitoring (AI API calls)

  ---
  Summary: Why This Approach is Better

  Old Approach (Metadata Storage):

  ❌ Store metadata for ALL emails❌ Modules filter using keywords
  (brittle)❌ Manual configuration required❌ False positives waste
  resources✅ Fast lookups

  New Approach (AI Routing):

  ✅ Zero email storage in Email Module✅ AI intelligently routes to
  interested modules✅ Modules self-describe in natural language✅ No 
  configuration needed - AI adapts automatically✅ Only fetch full emails
  when modules need them✅ Modules extract and store only what they need✅
  Learns from feedback to improve over time✅ Handles edge cases better than
   keyword matching

  Cost Comparison:

  | Metric          | Metadata Approach | AI Routing Approach      |
  |-----------------|-------------------|--------------------------|
  | Email storage   | 10 MB             | 0 MB                     |
  | AI cost         | $0                | $25/year                 |
  | Module storage  | N/A               | 125 KB (extracted data)  |
  | False positives | High              | Very low                 |
  | Configuration   | Manual            | Natural language         |
  | Adaptability    | Static rules      | Learns & improves        |
  | Total storage   | 10 MB             | 125 KB (98.8% reduction) |
  | Total cost      | $0.10/year        | $25/year                 |

  Verdict: $25/year for intelligent, zero-configuration, adaptive routing is
   an excellent trade-off!

  ---
  File Structure (Final)

  packages/
  ├── core/
  │   └── src/
  │       └── module-system/
  │           ├── IModule.ts (updated)
  │           └── IEmailHandler.ts (new)
  │
  └── modules/
      ├── email/                         # Thin routing layer
      │   ├── src/
      │   │   ├── domain/
      │   │   │   ├── value-objects/
      │   │   │   │   ├── EmailAddress.ts
      │   │   │   │   ├── EmailContext.ts
      │   │   │   │   └── EmailProvider.ts
      │   │   │   └── interfaces/
      │   │   │       └── IEmailProvider.ts
      │   │   ├── application/
      │   │   │   ├── services/
      │   │   │   │   ├── EmailRouterService.ts (AI routing!)
      │   │   │   │   └── EmailAccountService.ts
      │   │   │   └── use-cases/
      │   │   │       ├── RouteEmailUseCase.ts
      │   │   │       └── ConnectAccountUseCase.ts
      │   │   ├── infrastructure/
      │   │   │   ├── providers/
      │   │   │   │   ├── GmailProvider.ts
      │   │   │   │   ├── OutlookProvider.ts
      │   │   │   │   └── SmtpProvider.ts
      │   │   │   ├── ai/
      │   │   │   │   └── EmailRoutingAIClient.ts
      │   │   │   ├── cache/
      │   │   │   │   └── RoutingCacheService.ts
      │   │   │   └── webhooks/
      │   │   │       ├── GmailWebhookHandler.ts
      │   │   │       └── OutlookWebhookHandler.ts
      │   │   └── presentation/
      │   │       ├── controllers/
      │   │       │   ├── WebhookController.ts
      │   │       │   └── AccountController.ts
      │   │       └── routes/
      │   │           └── email.routes.ts
      │   └── module.json
      │
      ├── finance/                       # Implements IEmailHandler
      │   └── src/
      │       ├── email/                 # Email-specific code
      │       │   ├── FinanceEmailHandler.ts (implements IEmailHandler)
      │       │   └── InvoiceExtractor.ts (AI extraction)
      │       └── infrastructure/
      │           └── repositories/
      │               └── InvoiceRepository.ts (stores extracted data)
      │
      └── garden/                        # Implements IEmailHandler
          └── src/
              └── email/
                  ├── GardenEmailHandler.ts
                  └── OrderExtractor.ts

  ---
  Want me to start implementing this? I can:

  1. ✅ Start with Phase 1 - Create core interfaces and value objects
  2. ✅ Update Finance module - Add IEmailHandler implementation as example
  3. ✅ Build AI router - The intelligent email routing service
  4. ✅ Set up Gmail integration - First provider implementation

  Which phase should I start with?

> not sure we need AI modules can subscribe to the email module and receive 
it and then handle it in a worker of other thread per user so the main
system is not blocked what do you think as system architect ultrathink

⏺ Excellent point! Let me think through this as a system architect - the
  pub/sub pattern with background workers is actually simpler and better for
   your use case.

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Compare AI routing vs
                                                 Pub/Sub + Background
                                                Workers:\n\n**User's Approach
                                                (Pub/Sub + Workers):**\n1. Email
                                                 arrives → Email Module
                                                publishes event with
                                                metadata\n2. ALL interested
                                                modules subscribe to
                                                \"EmailReceived\" event\n3. Each
                                                 module filters in background
                                                worker (non-blocking)\n4. If
                                                relevant → fetch full email →
                                                process\n\n**Pros:**\n✅ Simpler
                                                 architecture (no AI
                                                complexity)\n✅ No AI cost ($0
                                                vs $25/year)\n✅ No AI latency
                                                (instant vs 500ms-2s)\n✅ No AI
                                                dependencies (fewer failure
                                                points)\n✅ Deterministic
                                                filtering (predictable,
                                                testable)\n✅ True decoupling
                                                (modules control their own
                                                logic)\n✅ Background workers
                                                prevent blocking (BullMQ)\n✅
                                                Each module can have
                                                sophisticated
                                                filtering\n\n**Cons:**\n❌ All
                                                modules receive all email events
                                                 (but it's just metadata, tiny
                                                cost)\n❌ Each module implements
                                                 filtering (but they need custom
                                                 logic anyway)\n\n**AI
                                                Approach:**\n✅ Smart upfront
                                                filtering\n✅ Only relevant
                                                modules notified\n❌ AI cost and
                                                 latency\n❌ Complex prompt
                                                engineering\n❌ Additional
                                                dependency\n❌ Less
                                                predictable\n\n**Verdict:** For
                                                LifeOS (single user/family,
                                                ~50-200 emails/day), pub/sub +
                                                workers is BETTER.",
                                                thoughtNumber: 1, totalThoughts:
                                                 6, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 1,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Architectural flow
                                                with Pub/Sub + Background
                                                Workers:\n\n```\nEmail arrives
                                                at provider\n  ↓\nWebhook →
                                                Email Module\n  ↓\nEmail Module
                                                syncs METADATA only to
                                                database\n  ↓\nEmail Module
                                                publishes event to EventBus:\n
                                                {\n    type: 'EmailReceived',\n
                                                   payload: {\n      id,
                                                accountId, from, to, subject,\n
                                                     snippet, hasAttachments,
                                                timestamp,\n
                                                providerMessageId\n    }\n  }\n
                                                 ↓\nEvent dispatched to ALL
                                                subscribed modules
                                                (non-blocking)\n  ↓\nEach module
                                                 receives event in background
                                                worker (BullMQ):\n  - Finance
                                                worker: \"Does this look like an
                                                 invoice?\"\n  - Garden worker:
                                                \"Is this from a supplier?\"\n
                                                - House worker: \"Is this a
                                                utility bill?\"\n  ↓\nIf module
                                                is interested:\n  - Fetch full
                                                email (lazy loading)\n  -
                                                Extract data with
                                                module-specific logic (AI
                                                optional)\n  - Store extracted
                                                data in module's own tables\n
                                                ↓\nDone (no blocking, each
                                                module
                                                independent)\n```\n\n**Key
                                                architectural decisions:**\n1.
                                                Email Module stores metadata
                                                (for lazy loading)\n2. EventBus
                                                broadcasts to all subscribers
                                                (Redis pub/sub)\n3. Each module
                                                has background worker queue
                                                (BullMQ)\n4. Modules fetch full
                                                email only when interested\n5.
                                                No central AI routing
                                                (decentralized filtering)",
                                                thoughtNumber: 2, totalThoughts:
                                                 6, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 2,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Worker architecture
                                                per module:\n\n**Email
                                                Module:**\n- Receives webhook\n-
                                                 Syncs metadata\n- Publishes
                                                event\n- Provides getEmail(id)
                                                API for lazy
                                                loading\n\n**Finance
                                                Module:**\n```typescript\n//
                                                Finance module subscribes in
                                                initialize()\neventBus.subscribe
                                                ('EmailReceived', async (event)
                                                => {\n  // Add to Finance email
                                                processing queue\n  await financ
                                                eEmailQueue.add('process-email',
                                                 {\n    emailId:
                                                event.payload.id,\n    metadata:
                                                 event.payload\n  });\n});\n\n//
                                                 Background worker processes
                                                queue\nfinanceEmailQueue.process
                                                ('process-email', async (job) =>
                                                 {\n  const { emailId, metadata
                                                } = job.data;\n  \n  // 1. Quick
                                                 filter with metadata\n  if
                                                (!isLikelyInvoice(metadata)) {\n
                                                    return; // Skip, no full
                                                email fetch needed\n  }\n  \n
                                                // 2. Fetch full email (lazy
                                                loading)\n  const email = await
                                                emailModule.getEmail(emailId);\n
                                                  \n  // 3. Extract invoice data
                                                 (AI or regex)\n  const invoice
                                                = await extractInvoice(email);\n
                                                  \n  // 4. Store in finance
                                                tables\n  await
                                                invoiceRepository.create(invoice
                                                );\n});\n```\n\n**Benefits:**\n-
                                                 Main thread never blocked\n-
                                                Each module has independent
                                                queue\n- Failed jobs retry
                                                automatically (BullMQ)\n- Rate
                                                limiting per module\n-
                                                Observability (queue metrics)",
                                                thoughtNumber: 3, totalThoughts:
                                                 6, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 3,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Storage strategy -
                                                still metadata only:\n\n**Email
                                                Module stores:**\n- Email
                                                metadata (from, to, subject,
                                                snippet, timestamp)\n- Provider
                                                message ID (for lazy loading)\n-
                                                 Flags (hasAttachments,
                                                labels)\n- ~200 bytes per
                                                email\n\n**Why store
                                                metadata?**\n1. Enable lazy
                                                loading (modules can fetch full
                                                email later)\n2. Allow modules
                                                to filter without fetching full
                                                content\n3. Provide search/query
                                                 capabilities\n4. Audit trail
                                                (which emails arrived)\n5. Retry
                                                 mechanism (if module processing
                                                 fails)\n\n**Metadata storage
                                                benefits:**\n- Module sees
                                                subject → decides to fetch full
                                                email\n- Module sees sender →
                                                skips irrelevant emails\n- No
                                                wasted API calls fetching full
                                                content for spam\n\n**Example
                                                filtering with metadata:**\n```t
                                                ypescript\nfinanceEmailQueue.pro
                                                cess('process-email', async
                                                (job) => {\n  const { metadata }
                                                 = job.data;\n  \n  // Filter
                                                with metadata BEFORE fetching
                                                full email\n  if
                                                (!metadata.subject.toLowerCase()
                                                .includes('invoice') &&\n
                                                !metadata.from.includes('billing
                                                @') &&\n
                                                !metadata.hasAttachments) {\n
                                                 return; // Skip - no API call
                                                to provider!\n  }\n  \n  // Only
                                                 fetch if metadata looks
                                                promising\n  const email = await
                                                 emailModule.getEmail(metadata.i
                                                d);\n  // ... process full
                                                email\n});\n```\n\n**Storage
                                                cost:** Still minimal (~200
                                                bytes × 50K emails =
                                                10MB/year)", thoughtNumber: 4,
                                                totalThoughts: 6,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 4,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "EventBus integration
                                                pattern:\n\n**EventBus is
                                                already in Core** - perfect fit
                                                for this!\n\nCurrent EventBus
                                                design (from CLAUDE.md):\n-
                                                Synchronous and asynchronous
                                                delivery ✓\n- Event persistence
                                                (event sourcing) ✓\n- Dead
                                                letter queue for failed handlers
                                                 ✓\n- Type-safe event
                                                subscriptions ✓\n\n**Email
                                                Module publishes
                                                event:**\n```typescript\nawait
                                                eventBus.publish({\n  type:
                                                'EmailReceived',\n  source:
                                                'email',\n  timestamp: new
                                                Date(),\n  payload: {\n    id:
                                                email.id,\n    accountId:
                                                email.accountId,\n    from: {
                                                address: email.from, name:
                                                email.fromName },\n    to:
                                                email.to,\n    subject:
                                                email.subject,\n    snippet:
                                                email.snippet,\n
                                                hasAttachments:
                                                email.hasAttachments,\n
                                                timestamp: email.timestamp,\n
                                                 labels: email.labels,\n    //
                                                Critical: provider message ID
                                                for lazy loading\n
                                                providerMessageId:
                                                email.providerMessageId,\n
                                                provider: email.provider\n  },\n
                                                  metadata: { accountEmail:
                                                account.email
                                                }\n});\n```\n\n**Modules
                                                subscribe (async
                                                delivery):**\n```typescript\neve
                                                ntBus.subscribe('EmailReceived',
                                                 async (event) => {\n  //
                                                Non-blocking: add to background
                                                queue\n  await
                                                moduleQueue.add('process-email',
                                                 event.payload);\n});\n```\n\n**
                                                EventBus handles:**\n- Async
                                                delivery to all subscribers\n-
                                                Retry if subscriber fails\n-
                                                Dead letter queue for permanent
                                                failures\n- Event persistence
                                                for audit trail\n\nPerfect! No
                                                changes needed to core
                                                EventBus.", thoughtNumber: 5,
                                                totalThoughts: 6,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 5,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Final architectural
                                                comparison and
                                                recommendation:\n\n**Pub/Sub +
                                                Workers Approach (User's
                                                suggestion):**\n\nComplexity:
                                                ⭐⭐ (Simple)\nCost: $0 (no
                                                AI)\nLatency: ~10ms (event
                                                publish)\nScalability:
                                                ⭐⭐⭐⭐⭐ (workers scale
                                                independently)\nReliability:
                                                ⭐⭐⭐⭐⭐ (BullMQ retries, dead
                                                 letter queue)\nFlexibility:
                                                ⭐⭐⭐⭐⭐ (modules control own
                                                filtering)\nTestability:
                                                ⭐⭐⭐⭐⭐
                                                (deterministic)\nDependencies:
                                                Redis + BullMQ (already in
                                                stack)\n\n**AI Routing
                                                Approach:**\n\nComplexity:
                                                ⭐⭐⭐⭐ (Complex)\nCost:
                                                ~$25/year (LLM API
                                                calls)\nLatency: ~500-2000ms (AI
                                                 inference)\nScalability: ⭐⭐⭐
                                                 (AI is
                                                bottleneck)\nReliability: ⭐⭐⭐
                                                 (AI failures
                                                possible)\nFlexibility: ⭐⭐⭐
                                                (prompt engineering
                                                needed)\nTestability: ⭐⭐⭐ (no
                                                n-deterministic)\nDependencies:
                                                Redis + BullMQ + LLM
                                                API\n\n**Recommendation: Pub/Sub
                                                 + Workers**\n\nWhy:\n1. LifeOS
                                                is single-user/family (not
                                                multi-tenant SaaS)\n2. Email
                                                volume is low (~50-200
                                                emails/day)\n3. All modules
                                                receiving events is negligible
                                                overhead\n4. Modules need custom
                                                 filtering logic anyway\n5.
                                                Simpler = fewer bugs, easier to
                                                maintain\n6. AI adds latency +
                                                cost with minimal benefit at
                                                this scale\n7. Workers prevent
                                                blocking regardless of filtering
                                                 approach\n\n**When AI routing
                                                makes sense:**\n- Multi-tenant
                                                SaaS (1000s of users)\n- High
                                                email volume (10K+ emails/day
                                                per user)\n- Many modules (>20)
                                                competing for emails\n- Need to
                                                minimize processing
                                                overhead\n\n**For LifeOS:**
                                                Pub/Sub + Workers is optimal!",
                                                thoughtNumber: 6, totalThoughts:
                                                 6, nextThoughtNeeded: false)
  ⎿  {                                                                     
       "thoughtNumber": 6,
       "totalThoughts": 6,
     … +4 lines (ctrl+o to expand)

⏺ System Architecture Analysis: You're Absolutely Right!

  As your system architect, I agree 100% - Pub/Sub + Background Workers is 
  the superior approach for LifeOS.

  Why Pub/Sub + Workers > AI Routing

  The Case Against AI Routing:

  - ❌ Overengineered for single-user system
  - ❌ $25/year cost with no real benefit at your scale
  - ❌ 500-2000ms latency for AI inference
  - ❌ Additional dependency (LLM API)
  - ❌ Non-deterministic (harder to test)
  - ❌ Complex prompt engineering needed

  The Case For Pub/Sub + Workers:

  - ✅ $0 cost - no AI needed
  - ✅ ~10ms latency - instant event publishing
  - ✅ Already in your stack (EventBus + BullMQ + Redis)
  - ✅ Simple and predictable - easy to test and debug
  - ✅ True decoupling - modules control their own logic
  - ✅ Non-blocking - workers prevent system bottlenecks
  - ✅ Scalable - each module scales independently
  - ✅ Flexible - modules can use AI for extraction, not routing

  ---
  Final Architecture: Pub/Sub + Workers

⏺ 1. Complete Flow

  ┌─────────────────────────────────────────────────────────────────┐
  │           Email arrives at Gmail/Outlook/SMTP                    │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  │ Webhook (push notification)
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │              Email Module - WebhookController                    │
  │  • Receives webhook notification                                │
  │  • Triggers SyncEmailsUseCase                                   │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │            Email Module - SyncEmailsUseCase                      │
  │  1. Fetch metadata from provider (not full email!)              │
  │  2. Store metadata in emails table                              │
  │     - from, to, subject, snippet, timestamp                     │
  │     - providerMessageId (for lazy loading)                      │
  │     - hasAttachments, labels                                    │
  │  3. Publish event to EventBus                                   │
  └───────────────────────────────┬─────────────────────────────────┘
                                  │
                                  ▼
  ┌─────────────────────────────────────────────────────────────────┐
  │                    EventBus (Core)                               │
  │  Event: EmailReceived                                           │
  │  Payload: { id, from, to, subject, snippet,                     │
  │             hasAttachments, providerMessageId }                 │
  │                                                                  │
  │  Async delivery to ALL subscribers (non-blocking)               │
  └──────────────┬──────────────────────────┬──────────────────────┘
                 │                          │
                 ▼                          ▼
  ┌──────────────────────────┐   ┌──────────────────────────┐
  │   Finance Module         │   │   Garden Module          │
  │   Event Subscriber       │   │   Event Subscriber       │
  └──────────┬───────────────┘   └──────────┬───────────────┘
             │                              │
             │ Add to queue                 │ Add to queue
             ▼                              ▼
  ┌──────────────────────────┐   ┌──────────────────────────┐
  │  Finance Email Queue     │   │  Garden Email Queue      │
  │  (BullMQ worker)         │   │  (BullMQ worker)         │
  │                          │   │                          │
  │  1. Filter metadata      │   │  1. Filter metadata      │
  │     "invoice" in subject?│   │     from supplier?       │
  │                          │   │                          │
  │  2. If yes → fetch full  │   │  2. If yes → fetch full  │
  │     email (lazy load)    │   │     email (lazy load)    │
  │                          │   │                          │
  │  3. Extract data (AI?)   │   │  3. Extract data (AI?)   │
  │                          │   │                          │
  │  4. Store in finance DB  │   │  4. Store in garden DB   │
  │                          │   │                          │
  │  5. Create tasks/events  │   │  5. Create tasks/events  │
  └──────────────────────────┘   └──────────────────────────┘

  ---
  2. Email Module: Metadata Storage + Lazy Loading

  Email Module Responsibilities:
  1. ✅ Sync email metadata from providers
  2. ✅ Store metadata in database
  3. ✅ Publish EmailReceived events
  4. ✅ Provide getEmail(id) API for lazy loading
  5. ❌ NO business logic (routing, filtering, extraction)

  Database Schema:

  // Email accounts
  model EmailAccount {
    id              String        @id @default(uuid())
    userId          String
    provider        EmailProvider
    email           String
    isActive        Boolean       @default(true)
    lastSyncedAt    DateTime?
    credentials     Json          // Encrypted OAuth tokens
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt

    emails          Email[]

    @@index([userId])
  }

  // Email metadata (for lazy loading + filtering)
  model Email {
    id                  String       @id @default(uuid())
    accountId           String
    providerMessageId   String       // Gmail/Outlook message ID
    provider            EmailProvider

    // Metadata for filtering
    from                String
    fromName            String?
    to                  String[]
    cc                  String[]
    subject             String
    snippet             String       // First 200 chars
    timestamp           DateTime

    // Flags
    threadId            String?
    hasAttachments      Boolean      @default(false)
    attachmentCount     Int          @default(0)
    labels              String[]
    isRead              Boolean      @default(false)
    sizeBytes           Int?

    createdAt           DateTime     @default(now())
    updatedAt           DateTime     @updatedAt

    account             EmailAccount @relation(fields: [accountId],
  references: [id], onDelete: Cascade)

    @@unique([accountId, providerMessageId])
    @@index([accountId])
    @@index([timestamp])
    @@index([from])
  }

  enum EmailProvider {
    GMAIL
    OUTLOOK
    SMTP
  }

  Storage: ~200 bytes × 50K emails = 10 MB (negligible!)

  ---
  3. Module Email Processing Pattern

⏺ Every module that wants emails follows this pattern:

  // packages/modules/finance/src/FinanceModule.ts
  export class FinanceModule implements IModule {
    private emailQueue: Queue;

    async initialize(context: ModuleContext): Promise<void> {
      // 1. Create dedicated email processing queue
      this.emailQueue = new Queue('finance-email-processing', {
        connection: context.redis
      });

      // 2. Subscribe to EmailReceived events
      context.eventBus.subscribe('EmailReceived', async (event) => {
        // Add to background queue (non-blocking!)
        await this.emailQueue.add('process-email', {
          emailId: event.payload.id,
          metadata: event.payload  // from, subject, snippet, etc.
        });
      });

      // 3. Start worker to process queue
      new Worker('finance-email-processing', async (job) => {
        await this.processEmail(job.data);
      }, {
        connection: context.redis,
        concurrency: 5  // Process 5 emails concurrently
      });
    }

    private async processEmail(data: EmailJobData): Promise<void> {
      const { emailId, metadata } = data;

      // Step 1: Quick filter with metadata (no API call!)
      if (!this.isRelevant(metadata)) {
        return; // Skip this email
      }

      // Step 2: Fetch full email (lazy loading)
      const emailResult = await this.emailModule.getEmail(emailId);
      if (emailResult.isFail()) {
        throw new Error('Failed to fetch email'); // BullMQ will retry
      }

      const email = emailResult.value;

      // Step 3: Extract data (AI optional, module decides)
      const extracted = await this.extractInvoiceData(email);

      if (!extracted.isInvoice) {
        return; // Not an invoice after all
      }

      // Step 4: Store extracted data
      await this.invoiceRepository.create({
        vendor: extracted.vendor,
        amount: Money.create(extracted.amount, extracted.currency),
        invoiceNumber: extracted.invoiceNumber,
        dueDate: extracted.dueDate,
        sourceEmailId: emailId,  // Reference for re-fetching
        sourceEmailProvider: metadata.provider
      });

      // Step 5: Create related tasks/events
      await this.taskRepository.create({
        title: `Pay invoice ${extracted.invoiceNumber}`,
        description: `${extracted.vendor} - ${extracted.amount}`,
        dueDate: extracted.dueDate,
        type: 'payment'
      });

      // Step 6: Publish domain event
      await this.eventBus.publish({
        type: 'InvoiceReceived',
        source: 'finance',
        payload: { invoiceId: invoice.id }
      });
    }

    private isRelevant(metadata: EmailMetadata): boolean {
      // Fast filtering with metadata (no full email fetch)
      const subject = metadata.subject.toLowerCase();
      const from = metadata.from.toLowerCase();

      // Check keywords
      if (subject.includes('invoice') ||
          subject.includes('factuur') ||
          subject.includes('receipt')) {
        return true;
      }

      // Check sender domains
      const financialSenders = [
        'paypal.com', 'stripe.com', 'invoices@',
        'billing@', 'accounting@'
      ];
      if (financialSenders.some(sender => from.includes(sender))) {
        return true;
      }

      // Likely has invoice PDF
      if (metadata.hasAttachments &&
          (subject.includes('payment') || subject.includes('bill'))) {
        return true;
      }

      return false;
    }

    private async extractInvoiceData(email: EmailContent):
  Promise<InvoiceData> {
      // Module decides: use AI, regex, or custom logic

      // Option 1: AI extraction (use if needed)
      if (this.useAI) {
        return await this.aiExtractor.extractInvoice(email);
      }

      // Option 2: Regex/manual parsing
      return this.parseInvoiceManually(email);
    }
  }

  ---
  4. Email Module API (Lazy Loading)

⏺ // packages/modules/email/src/application/use-cases/GetEmailUseCase.ts
  export class GetEmailUseCase {
    constructor(
      private emailRepository: IEmailRepository,
      private emailProviderFactory: EmailProviderFactory,
      private emailCache: EmailCacheService
    ) {}

    async execute(emailId: string): Promise<Result<EmailContent, BaseError>>
   {
      // 1. Get metadata from repository
      const metadataResult = await this.emailRepository.findById(emailId);
      if (metadataResult.isFail()) {
        return Result.fail(metadataResult.error);
      }

      const metadata = metadataResult.value;

      // 2. Check Redis cache (1-hour TTL)
      const cacheKey = `email:content:${emailId}`;
      const cached = await this.emailCache.get(cacheKey);

      if (cached) {
        return Result.ok({
          ...metadata,
          body: cached.body,
          htmlBody: cached.htmlBody,
          attachments: cached.attachments
        });
      }

      // 3. Fetch from provider (Gmail/Outlook/SMTP)
      const provider = this.emailProviderFactory.create(metadata.provider);
      const contentResult = await
  provider.fetchEmail(metadata.providerMessageId);

      if (contentResult.isFail()) {
        return Result.fail(contentResult.error);
      }

      const content = contentResult.value;

      // 4. Cache for 1 hour (compressed)
      await this.emailCache.set(cacheKey, content, 3600);

      // 5. Return full email
      return Result.ok({
        ...metadata,
        ...content
      });
    }
  }

  // packages/modules/email/src/EmailModule.ts
  export class EmailModule implements IModule {
    // Public API for other modules
    async getEmail(emailId: string): Promise<Result<EmailContent,
  BaseError>> {
      const useCase = new GetEmailUseCase(
        this.emailRepository,
        this.emailProviderFactory,
        this.emailCache
      );
      return await useCase.execute(emailId);
    }

    async searchEmails(filter: EmailFilter): Promise<Result<Email[],
  BaseError>> {
      // Query metadata only
      return await this.emailRepository.findByFilter(filter);
    }
  }

  Benefits:
  - ✅ Cache prevents duplicate API calls (multiple modules requesting same
  email)
  - ✅ Compressed cache reduces Redis memory
  - ✅ Metadata queries don't hit provider APIs
  - ✅ Simple, predictable behavior

  ---
  5. Worker Queue Architecture

  Each module gets its own queue:

  // Finance Module
  financeEmailQueue = new Queue('finance-email-processing');

  // Garden Module
  gardenEmailQueue = new Queue('garden-email-processing');

  // House Maintenance Module
  houseEmailQueue = new Queue('house-email-processing');

  Worker configuration:

  new Worker('finance-email-processing', async (job) => {
    await processFinanceEmail(job.data);
  }, {
    connection: redis,
    concurrency: 5,        // Process 5 emails at once
    limiter: {
      max: 10,             // Max 10 jobs per...
      duration: 1000       // ...1 second (rate limiting)
    },
    attempts: 3,           // Retry failed jobs 3 times
    backoff: {
      type: 'exponential', // Exponential backoff
      delay: 2000          // Start with 2s delay
    }
  });

  Queue metrics (built-in):

  // Monitor queue health
  const metrics = await financeEmailQueue.getMetrics();
  console.log({
    waiting: metrics.waiting,      // Emails waiting to process
    active: metrics.active,        // Currently processing
    completed: metrics.completed,  // Successfully processed
    failed: metrics.failed,        // Failed jobs (check errors!)
    avgProcessTime: metrics.avgProcessTime
  });

  ---
  6. Module Structure

  packages/modules/finance/
  ├── src/
  │   ├── domain/
  │   │   ├── entities/
  │   │   │   └── Invoice.ts
  │   │   └── interfaces/
  │   │       └── IInvoiceRepository.ts
  │   │
  │   ├── application/
  │   │   ├── use-cases/
  │   │   │   └── CreateInvoiceUseCase.ts
  │   │   └── services/
  │   │       ├── EmailProcessingService.ts    # Email filtering logic
  │   │       └── InvoiceExtractor.ts          # Data extraction
  │   │
  │   ├── infrastructure/
  │   │   ├── repositories/
  │   │   │   └── InvoiceRepository.ts
  │   │   ├── jobs/
  │   │   │   └── EmailProcessingWorker.ts     # BullMQ worker
  │   │   └── extractors/
  │   │       ├── AIInvoiceExtractor.ts        # AI-powered (optional)
  │   │       └── RegexInvoiceExtractor.ts     # Regex-based
  │   │
  │   ├── presentation/
  │   │   └── controllers/
  │   │       └── InvoiceController.ts
  │   │
  │   └── FinanceModule.ts                     # Module initialization
  │
  └── module.json

  FinanceModule initialization:

  export class FinanceModule implements IModule {
    name = 'finance';
    version = '1.0.0';

    private emailQueue: Queue;
    private emailWorker: Worker;

    async initialize(context: ModuleContext): Promise<void> {
      // 1. Setup email processing queue
      this.emailQueue = new Queue('finance-email-processing', {
        connection: context.redis
      });

      // 2. Subscribe to email events
      context.eventBus.subscribe('EmailReceived', async (event) => {
        await this.emailQueue.add('process-email', {
          emailId: event.payload.id,
          metadata: event.payload
        });
      });

      // 3. Start worker
      this.emailWorker = new Worker(
        'finance-email-processing',
        async (job) => {
          const service = new EmailProcessingService(
            context.emailModule,
            this.invoiceRepository,
            this.taskRepository,
            context.eventBus
          );
          await service.processEmail(job.data);
        },
        {
          connection: context.redis,
          concurrency: 5
        }
      );
    }

    async shutdown(): Promise<void> {
      await this.emailQueue.close();
      await this.emailWorker.close();
    }
  }

  ---
  7. Example: Finance Module Email Processing

  // packages/modules/finance/src/application/services/EmailProcessingServic
  e.ts
  export class EmailProcessingService {
    constructor(
      private emailModule: EmailModule,
      private invoiceRepository: IInvoiceRepository,
      private taskRepository: ITaskRepository,
      private eventBus: EventBus
    ) {}

    async processEmail(data: EmailJobData): Promise<void> {
      const { emailId, metadata } = data;

      // Step 1: Fast filter with metadata
      if (!this.looksLikeInvoice(metadata)) {
        console.log(`Skipping email ${emailId}: not relevant`);
        return;
      }

      console.log(`Processing potential invoice: ${metadata.subject}`);

      // Step 2: Fetch full email (lazy loading)
      const emailResult = await this.emailModule.getEmail(emailId);
      if (emailResult.isFail()) {
        throw new Error(`Failed to fetch email: 
  ${emailResult.error.message}`);
      }

      const email = emailResult.value;

      // Step 3: Extract invoice data
      const extractor = new AIInvoiceExtractor(); // or 
  RegexInvoiceExtractor
      const extractionResult = await extractor.extract(email);

      if (extractionResult.isFail() || !extractionResult.value.isInvoice) {
        console.log(`Not an invoice after all: ${metadata.subject}`);
        return;
      }

      const invoiceData = extractionResult.value;

      // Step 4: Create invoice entity
      const invoice = Invoice.create({
        vendor: invoiceData.vendor,
        amount: Money.create(invoiceData.amount, invoiceData.currency),
        invoiceNumber: invoiceData.invoiceNumber,
        dueDate: invoiceData.dueDate,
        lineItems: invoiceData.lineItems,
        sourceEmailId: emailId,
        sourceEmailProvider: metadata.provider
      });

      // Step 5: Save to database
      const saveResult = await this.invoiceRepository.create(invoice);
      if (saveResult.isFail()) {
        throw new Error(`Failed to save invoice: 
  ${saveResult.error.message}`);
      }

      console.log(`✓ Created invoice: ${invoiceData.invoiceNumber}`);

      // Step 6: Create payment task
      await this.taskRepository.create({
        title: `Pay invoice ${invoiceData.invoiceNumber}`,
        description: `${invoiceData.vendor} - €${invoiceData.amount}`,
        dueDate: invoiceData.dueDate,
        type: 'payment',
        priority: 'medium',
        metadata: { invoiceId: invoice.id }
      });

      // Step 7: Publish event
      await this.eventBus.publish({
        type: 'InvoiceReceived',
        source: 'finance',
        payload: {
          invoiceId: invoice.id,
          vendor: invoiceData.vendor,
          amount: invoiceData.amount,
          dueDate: invoiceData.dueDate
        }
      });

      console.log(`✓ Published InvoiceReceived event`);
    }

    private looksLikeInvoice(metadata: EmailMetadata): boolean {
      const subject = metadata.subject.toLowerCase();
      const from = metadata.from.toLowerCase();

      // Keyword matching
      const keywords = ['invoice', 'factuur', 'receipt', 'bill', 'payment'];
      if (keywords.some(kw => subject.includes(kw))) {
        return true;
      }

      // Known financial senders
      const senders = [
        'paypal.com', 'stripe.com', 'invoices@',
        'billing@', 'noreply@', 'accounting@'
      ];
      if (senders.some(s => from.includes(s))) {
        return true;
      }

      // Has PDF attachment (likely invoice)
      if (metadata.hasAttachments) {
        return true;
      }

      return false;
    }
  }

  ---
  8. Performance Analysis

  Email Volume: 200 emails/day

  Event Broadcasting:
  - 200 events/day published to EventBus
  - Each event: ~500 bytes (metadata only)
  - Total data: 100 KB/day (negligible)

  Worker Processing:
  - Finance module: ~50 emails/day match filter → fetch full email
  - Garden module: ~10 emails/day match filter → fetch full email
  - House module: ~20 emails/day match filter → fetch full email
  - Total API calls: ~80/day (vs 200 if no filtering)
  - Savings: 60% fewer API calls

  Latency:
  - Event publish: ~10ms
  - Queue add: ~5ms
  - Worker pickup: ~100ms
  - Full email fetch: ~500ms (cached: ~10ms)
  - Processing: ~2-5s (AI extraction)
  - Total: ~3-6s end-to-end (non-blocking!)

  Resource Usage:
  - Redis memory: ~10 MB (metadata) + ~50 MB (cache) = 60 MB
  - PostgreSQL: ~10 MB (metadata) + module data
  - BullMQ overhead: ~1 MB per queue

  Scalability:
  - Handle 10,000 emails/day easily
  - Add more workers if needed (horizontal scaling)
  - Each module scales independently

  ---
  9. Final Architecture Summary

⏺ Email Module (Shared Infrastructure):
  - ✅ Syncs metadata from Gmail/Outlook/SMTP
  - ✅ Stores metadata in PostgreSQL (~200 bytes/email)
  - ✅ Publishes EmailReceived events to EventBus
  - ✅ Provides getEmail(id) API for lazy loading
  - ✅ Caches full emails in Redis (1-hour TTL)
  - ❌ NO routing logic
  - ❌ NO data extraction
  - ❌ NO business logic

  Domain Modules (Finance, Garden, etc.):
  - ✅ Subscribe to EmailReceived events
  - ✅ Add events to background queue (BullMQ)
  - ✅ Worker filters with metadata
  - ✅ Fetch full email if relevant (lazy loading)
  - ✅ Extract data (AI optional, module decides)
  - ✅ Store extracted data in own tables
  - ✅ Create tasks/events as needed

  Benefits:
  - ✅ Simple - no AI complexity
  - ✅ Fast - ~10ms event latency
  - ✅ Non-blocking - workers prevent bottlenecks
  - ✅ Scalable - modules scale independently
  - ✅ Flexible - modules control own logic
  - ✅ Cost-effective - $0 infrastructure cost
  - ✅ Testable - deterministic behavior
  - ✅ Reliable - BullMQ retries, dead letter queue

  ---
  Recommendation

  ✅ Implement Pub/Sub + Workers approach

  This is the right choice for LifeOS because:

  1. Perfect fit for your scale (single-user, ~200 emails/day)
  2. Leverages existing stack (EventBus, BullMQ, Redis already there)
  3. Non-blocking by design (as you correctly identified)
  4. True modularity (modules own their filtering logic)
  5. AI optional (modules can use AI for extraction, not routing)
  6. Simple to test and maintain

  AI routing would be overengineering with no real benefit at your scale.

  ---
  Next Steps

  Want me to implement this? I can start with:

  1. Email Module core - Metadata storage + lazy loading
  2. Gmail Provider - OAuth + webhook + fetch API
  3. Finance Module example - Complete email processing with worker
  4. Testing - E2E test showing email → event → worker → extraction

  Which phase should I start with?

> ultrathink i would make it possible that when a module register it can use
 ai to macth a filter to see if the mail is good for them or bot you as
system architect need to find the best way for exmple this module for sees
functions that can be used or that the receiving module need to do it self
what is the best way

⏺ Excellent question! Let me think through where AI filtering should live
  and what's the optimal architecture.

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "Where should AI
                                                filtering live? Three
                                                options:\n\n**Option 1:
                                                Centralized - Email Module
                                                provides AI filtering**\n-
                                                Modules register filters with
                                                Email Module\n- Email Module
                                                runs AI to evaluate all
                                                filters\n- Only publishes events
                                                 to interested
                                                modules\n\n**Option 2:
                                                Decentralized - Each module does
                                                 own AI filtering**\n- Email
                                                Module broadcasts to all
                                                modules\n- Each module calls AI
                                                independently to decide\n-
                                                Modules control their own AI
                                                logic\n\n**Option 3: Hybrid -
                                                Email Module provides optional
                                                AI helpers**\n- Email Module
                                                offers AI filtering utilities\n-
                                                 Modules can use them or
                                                implement custom logic\n-
                                                Centralized optimization,
                                                decentralized control\n\nLet me
                                                analyze each...", thoughtNumber:
                                                 1, totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 1,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Option 1 Analysis:
                                                Centralized AI in Email
                                                Module**\n\nFlow:\n```\nEmail
                                                arrives → Email Module\n
                                                ↓\nCollect all registered module
                                                 filters\n  ↓\nSingle AI call:
                                                \"Which modules want this
                                                email?\"\n  Input: Email
                                                metadata + all module filter
                                                descriptions\n  Output:
                                                [\"finance\", \"garden\"]\n
                                                ↓\nPublish targeted events (not
                                                broadcast)\n  -
                                                EmailReceived.finance → Finance
                                                module only\n  -
                                                EmailReceived.garden → Garden
                                                module only\n```\n\nPros:\n✅
                                                ONE AI call per email
                                                (efficient)\n✅ Batch evaluation
                                                 of all filters\n✅ Centralized
                                                caching (similar emails reuse AI
                                                 decision)\n✅ No wasted worker
                                                processing\n✅ Email Module
                                                controls AI quality\n\nCons:\n❌
                                                 Email Module couples to module
                                                filter logic\n❌ Modules can't
                                                customize AI prompts\n❌ Less
                                                flexible for advanced use
                                                cases\n\nCost: ~500 tokens per
                                                email × $0.000001 =
                                                $0.0005/email\nFor 200
                                                emails/day: $0.10/day =
                                                $36/year\n\nThis is actually
                                                VERY cheap for the benefit!",
                                                thoughtNumber: 2, totalThoughts:
                                                 8, nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 2,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Option 2 Analysis:
                                                Decentralized AI in Each
                                                Module**\n\nFlow:\n```\nEmail
                                                arrives → Email Module\n
                                                ↓\nPublish EmailReceived to ALL
                                                modules (broadcast)\n
                                                ↓\nFinance module worker:\n  -
                                                Calls AI: \"Is this an
                                                invoice?\"\n  - If yes → fetch
                                                full email\n  ↓\nGarden module
                                                worker:\n  - Calls AI: \"Is this
                                                 from a supplier?\"\n  - If yes
                                                → fetch full email\n  ↓\nHouse
                                                module worker:\n  - Calls AI:
                                                \"Is this a utility bill?\"\n  -
                                                 If yes → fetch full
                                                email\n```\n\nPros:\n✅ Maximum
                                                flexibility (each module
                                                controls AI)\n✅ True decoupling
                                                 (Email Module stays thin)\n✅
                                                Modules can use different AI
                                                providers\n✅ Custom prompt
                                                engineering per
                                                module\n\nCons:\n❌ 3-5 AI calls
                                                 per email (wasteful)\n❌ No
                                                centralized caching\n❌ All
                                                workers activated (even if not
                                                relevant)\n❌ Harder to optimize
                                                 costs\n\nCost: 5 modules × 500
                                                tokens × $0.000001 =
                                                $0.0025/email\nFor 200
                                                emails/day: $0.50/day =
                                                $182/year (5x more
                                                expensive!)\n\nAlso, all workers
                                                 spin up even if email is spam →
                                                 wasted CPU.", thoughtNumber: 3,
                                                 totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 3,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Option 3 Analysis:
                                                Hybrid - Email Module Provides
                                                AI Utilities**\n\nModule
                                                registration supports multiple
                                                filter types:\n\n```typescript\n
                                                emailModule.registerFilter({\n
                                                moduleName: 'finance',\n  \n  //
                                                 Option A: AI-powered filter
                                                (centralized)\n  aiFilter: {\n
                                                  description: \"Invoices,
                                                receipts, billing, payments\",\n
                                                    examples: [\"Invoice #123
                                                from Acme\", \"PayPal
                                                receipt\"]\n  },\n  \n  //
                                                Option B: Quick keyword filter
                                                (fast, cheap)\n  quickFilter:
                                                (metadata) => {\n    return meta
                                                data.subject.includes('invoice')
                                                 ||\n           metadata.from.in
                                                cludes('billing@');\n  },\n  \n
                                                 // Option C: Both (keyword
                                                first, AI fallback)\n
                                                quickFilter: (metadata) => { /*
                                                fast check */ },\n  aiFilter: {
                                                /* AI for ambiguous cases */
                                                }\n});\n```\n\n**Smart
                                                evaluation cascade:**\n1. Run
                                                all quickFilters (fast, 0
                                                cost)\n2. If any module
                                                uncertain → ONE AI call for
                                                those modules\n3. Publish events
                                                 only to interested
                                                modules\n\nExample
                                                flow:\n```\nEmail: \"Monthly
                                                report from
                                                garden-supplier.com\"\n\nStep 1
                                                - Quick filters:\n
                                                Finance.quickFilter: false (no
                                                'invoice')\n
                                                Garden.quickFilter: true! (from
                                                supplier)\n  House.quickFilter:
                                                false\n  \nResult: Only Garden
                                                module receives event\nAI calls:
                                                 0\n```\n\nAnother
                                                example:\n```\nEmail:
                                                \"Important document from
                                                unknown@company.com\"\n\nStep 1
                                                - Quick filters:\n
                                                Finance.quickFilter: uncertain\n
                                                  Garden.quickFilter: uncertain
                                                 \n  House.quickFilter:
                                                uncertain\n\nStep 2 - AI
                                                evaluation:\n  Single AI call:
                                                \"Which modules want this
                                                email?\"\n  Result:
                                                [\"finance\"] (it's an
                                                invoice)\n  \nResult: Only
                                                Finance module receives
                                                event\nAI calls: 1 (evaluated 3
                                                modules at once)\n```\n\nThis is
                                                 PERFECT!", thoughtNumber: 4,
                                                totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 4,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Hybrid Approach -
                                                Cost and Performance
                                                Analysis:**\n\nRealistic
                                                distribution for 200
                                                emails/day:\n- 100 emails: Quick
                                                 filter matches (invoices,
                                                obvious senders) → 0 AI calls\n-
                                                 50 emails: Quick filter rejects
                                                 all (spam, newsletters) → 0 AI
                                                calls  \n- 50 emails: Ambiguous
                                                → 1 AI call each\n\nTotal AI
                                                calls: 50/day\nCost: 50 × 500
                                                tokens × $0.000001 = $0.025/day
                                                = $9/year\n\n**Compared to:**\n-
                                                 Centralized AI (Option 1):
                                                $36/year (AI for every email)\n-
                                                 Decentralized AI (Option 2):
                                                $182/year (AI per module per
                                                email)\n\n**Hybrid wins on cost:
                                                 $9/year (75% cheaper than
                                                centralized!)**\n\n**Performance
                                                :**\n- Quick filters: ~1ms per
                                                module (JavaScript execution)\n-
                                                 AI call (if needed): ~500ms\n-
                                                Average latency: (150 emails ×
                                                1ms + 50 emails × 500ms) / 200 =
                                                 125ms\n\n**Benefits:**\n✅
                                                Cheapest option ($9/year vs $36
                                                or $182)\n✅ Fastest for obvious
                                                 emails (1ms)\n✅ Modules
                                                control both quick and AI
                                                logic\n✅ Progressive
                                                enhancement (start simple, add
                                                AI later)\n✅ Centralized AI
                                                optimization (batch
                                                evaluation)\n✅ Minimal worker
                                                waste (only relevant modules
                                                notified)\n\nThis is the
                                                winner!", thoughtNumber: 5,
                                                totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 5,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Module Filter
                                                Registration Interface Design:**
                                                \n\n```typescript\ninterface
                                                IEmailFilter {\n  moduleName:
                                                string;\n  \n  // Optional: Fast
                                                 keyword/regex filter (runs
                                                first)\n  quickFilter?:
                                                (metadata: EmailMetadata) =>
                                                boolean | 'uncertain';\n  \n  //
                                                 Optional: AI-powered filter
                                                (runs if quickFilter returns
                                                uncertain)\n  aiFilter?: {\n
                                                description: string;     // What
                                                 emails this module handles\n
                                                 examples: string[];      //
                                                Example subjects/content\n
                                                keywords?: string[];     //
                                                High-confidence keywords
                                                (optional)\n  };\n  \n  //
                                                Priority (if multiple modules
                                                match)\n  priority?:
                                                number;\n}\n```\n\n**Module
                                                registration
                                                examples:**\n\n```typescript\n//
                                                 Finance Module - Hybrid
                                                approach\nemailModule.registerFi
                                                lter({\n  moduleName:
                                                'finance',\n  \n  quickFilter:
                                                (metadata) => {\n    const
                                                subject = metadata.subject.toLow
                                                erCase();\n    const from =
                                                metadata.from.toLowerCase();\n
                                                  \n    // Definite match\n
                                                if (subject.includes('invoice')
                                                || from.includes('billing@'))
                                                {\n      return true;\n    }\n
                                                  \n    // Definite reject\n
                                                if
                                                (subject.includes('newsletter')
                                                || from.includes('marketing@'))
                                                {\n      return false;\n    }\n
                                                   \n    // Uncertain - let AI
                                                decide\n    if
                                                (metadata.hasAttachments) {\n
                                                   return 'uncertain';  // Could
                                                 be invoice PDF\n    }\n    \n
                                                  return false;\n  },\n  \n
                                                aiFilter: {\n    description:
                                                \"Invoices, receipts, billing,
                                                payments, financial
                                                documents\",\n    examples: [\n
                                                     \"Invoice #12345 from Acme
                                                Corp\",\n      \"Your PayPal
                                                payment was successful\",\n
                                                 \"Monthly credit card
                                                statement\"\n    ],\n
                                                keywords: ['invoice', 'factuur',
                                                 'receipt', 'payment',
                                                'billing']\n  },\n  \n
                                                priority: 10\n});\n\n// Garden
                                                Module - AI-only approach (no
                                                quick filter)\nemailModule.regis
                                                terFilter({\n  moduleName:
                                                'garden',\n  \n  aiFilter: {\n
                                                  description: `\n      Orders
                                                and communications from garden
                                                suppliers, seed companies,\n
                                                  and landscaping services.
                                                Plant care tips, delivery
                                                notifications,\n      gardening
                                                newsletters.\n    `,\n
                                                examples: [\n      \"Your order
                                                of tomato seeds has shipped\",\n
                                                      \"Spring planting
                                                guide\",\n      \"Delivery
                                                scheduled for garden tools\"\n
                                                  ]\n  }\n});\n\n// Newsletter
                                                Module - Quick filter only (no
                                                AI needed)\nemailModule.register
                                                Filter({\n  moduleName:
                                                'newsletter',\n  \n
                                                quickFilter: (metadata) => {\n
                                                  return metadata.subject.toLowe
                                                rCase().includes('newsletter')
                                                ||\n           metadata.from.inc
                                                ludes('unsubscribe');\n
                                                }\n});\n```\n\nThis interface
                                                gives modules complete
                                                flexibility!", thoughtNumber: 6,
                                                 totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 6,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Email Module -
                                                Filter Evaluation Service
                                                Implementation:**\n\n```typescri
                                                pt\nclass EmailFilterService {\n
                                                  private filters: Map<string,
                                                IEmailFilter> = new Map();\n  \n
                                                  registerFilter(filter:
                                                IEmailFilter): void {\n    this.
                                                filters.set(filter.moduleName,
                                                filter);\n  }\n  \n  async
                                                evaluateFilters(metadata:
                                                EmailMetadata):
                                                Promise<string[]> {\n    // Step
                                                 1: Run quick filters (fast,
                                                synchronous)\n    const
                                                quickResults = new Map<string,
                                                boolean | 'uncertain'>();\n
                                                const uncertainModules:
                                                IEmailFilter[] = [];\n    const
                                                matchedModules: string[] = [];\n
                                                    \n    for (const
                                                [moduleName, filter] of
                                                this.filters) {\n      if
                                                (filter.quickFilter) {\n
                                                const result =
                                                filter.quickFilter(metadata);\n

                                                quickResults.set(moduleName,
                                                result);\n        \n        if
                                                (result === true) {\n
                                                matchedModules.push(moduleName);
                                                \n        } else if (result ===
                                                'uncertain') {\n
                                                uncertainModules.push(filter);\n
                                                        }\n        // If false,
                                                skip this module\n      } else
                                                if (filter.aiFilter) {\n
                                                // No quick filter, AI needed\n

                                                uncertainModules.push(filter);\n
                                                      }\n    }\n    \n    //
                                                Step 2: If any modules
                                                uncertain, run ONE AI call\n
                                                if (uncertainModules.length > 0)
                                                 {\n      const aiMatches =
                                                await
                                                this.evaluateWithAI(metadata,
                                                uncertainModules);\n      matche
                                                dModules.push(...aiMatches);\n
                                                  }\n    \n    return
                                                matchedModules;\n  }\n  \n
                                                private async evaluateWithAI(\n
                                                   metadata: EmailMetadata,\n
                                                 filters: IEmailFilter[]\n  ):
                                                Promise<string[]> {\n    //
                                                Check cache first\n    const
                                                cacheKey =
                                                this.getCacheKey(metadata,
                                                filters);\n    const cached =
                                                await
                                                this.cache.get(cacheKey);\n
                                                if (cached) return cached;\n
                                                \n    // Build prompt with all
                                                uncertain module filters\n
                                                const prompt =
                                                this.buildAIPrompt(metadata,
                                                filters);\n    \n    // Single
                                                AI call evaluates ALL uncertain
                                                modules\n    const response =
                                                await this.aiClient.complete({\n
                                                      prompt,\n
                                                temperature: 0.1,\n
                                                maxTokens: 200\n    });\n    \n
                                                   // Parse: [\"finance\",
                                                \"garden\"]\n    const matches =
                                                 this.parseAIResponse(response);
                                                \n    \n    // Cache for 7 days
                                                (similar emails reuse
                                                decision)\n    await
                                                this.cache.set(cacheKey,
                                                matches, 604800);\n    \n
                                                return matches;\n  }\n  \n
                                                private buildAIPrompt(\n
                                                metadata: EmailMetadata,\n
                                                filters: IEmailFilter[]\n  ):
                                                string {\n    const
                                                moduleDescriptions = filters\n
                                                    .map(f => `\n##
                                                ${f.moduleName}\n${f.aiFilter!.d
                                                escription}\n\nExamples:
                                                ${f.aiFilter!.examples.join(',
                                                ')}\nKeywords:
                                                ${f.aiFilter!.keywords?.join(',
                                                ') || 'None'}\n`)\n
                                                .join('\\n');\n    \n    return
                                                `\nAnalyze this email and
                                                determine which module(s) should
                                                 process it.\n\nEmail:\n- From:
                                                ${metadata.from}\n- Subject:
                                                ${metadata.subject}\n- Preview:
                                                ${metadata.snippet}\n- Has
                                                Attachments: ${metadata.hasAttac
                                                hments}\n\nModules:\n${moduleDes
                                                criptions}\n\nReturn ONLY a JSON
                                                 array of module names that
                                                should receive this
                                                email:\n[\"finance\"] or
                                                [\"garden\", \"house\"] or
                                                []\n\nResponse:`;\n  }\n  \n
                                                private getCacheKey(metadata:
                                                EmailMetadata, filters:
                                                IEmailFilter[]): string {\n
                                                // Hash based on sender domain +
                                                 subject keywords + filter set\n
                                                    const domain =
                                                metadata.from.split('@')[1];\n
                                                  const keywords = this.extractK
                                                eywords(metadata.subject);\n
                                                const filterNames =
                                                filters.map(f => f.moduleName).s
                                                ort().join('-');\n    return
                                                `filter:${domain}:${keywords}:${
                                                filterNames}`;\n
                                                }\n}\n```\n\n**Benefits:**\n-
                                                One class handles all filtering
                                                logic\n- Quick filters run
                                                synchronously (fast)\n- AI
                                                called only when needed\n- Batch
                                                 AI evaluation (efficient)\n-
                                                Caching prevents duplicate AI
                                                calls\n- Clean separation of
                                                concerns", thoughtNumber: 7,
                                                totalThoughts: 8,
                                                nextThoughtNeeded: true)
  ⎿  {                                                                     
       "thoughtNumber": 7,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ sequential-thinking - sequentialthinking (MCP)(thought: "**Complete Flow with
                                                Hybrid Filtering:**\n\n```\n1.
                                                Email arrives → Email Module
                                                webhook\n   ↓\n2. Email Module
                                                syncs metadata\n   ↓\n3.
                                                EmailFilterService.evaluateFilte
                                                rs(metadata)\n   ↓\n   3a. Run
                                                all quickFilters (1-5ms)\n
                                                 - Finance: true (subject has
                                                \"invoice\") ✓\n       - Garden:
                                                 false (not from supplier)\n
                                                   - House: 'uncertain' (has
                                                attachment, could be bill)\n
                                                ↓\n   3b. Collect uncertain
                                                modules: [House]\n   ↓\n   3c.
                                                ONE AI call for uncertain
                                                modules\n       - Check cache
                                                first (7-day TTL)\n       - If
                                                miss → AI determines:
                                                [\"house\"] ✓\n   ↓\n   3d.
                                                Combine results: [\"finance\",
                                                \"house\"]\n   ↓\n4. Publish
                                                targeted events:\n   -
                                                EmailReceived → Finance module
                                                (with metadata)\n   -
                                                EmailReceived → House module
                                                (with metadata)\n   - (Garden
                                                module NOT notified - saves
                                                CPU)\n   ↓\n5. Each matched
                                                module:\n   - Receives event in
                                                worker queue\n   - Fetches full
                                                email if needed\n   - Extracts
                                                data\n   - Stores in own
                                                tables\n```\n\n**Final
                                                Recommendation: HYBRID
                                                APPROACH**\n\nEmail Module
                                                provides:\n- ✅ Filter
                                                registration API\n- ✅ Quick
                                                filter evaluation
                                                (synchronous)\n- ✅ AI filter
                                                evaluation (cached, batched)\n-
                                                ✅ Targeted event
                                                publishing\n\nModules can
                                                choose:\n- ✅ Quick filter only
                                                (fastest, free)\n- ✅ AI filter
                                                only (smart, minimal code)\n- ✅
                                                 Both (optimal: fast path +
                                                smart
                                                fallback)\n\n**Benefits:**\n-
                                                Cheapest: $9/year (vs $36 or
                                                $182)\n- Fastest: 1ms for
                                                obvious emails\n- Flexible:
                                                modules control logic\n-
                                                Efficient: one AI call for
                                                multiple uncertain modules\n-
                                                Scalable: cached decisions, no
                                                redundant processing\n\nThis is
                                                the perfect balance of
                                                simplicity, cost, performance,
                                                and flexibility!",
                                                thoughtNumber: 8, totalThoughts:
                                                 8, nextThoughtNeeded: false)
  ⎿  {                                                                     
       "thoughtNumber": 8,
       "totalThoughts": 8,
     … +4 lines (ctrl+o to expand)

⏺ System Architect Recommendation: Hybrid Filtering Approach

  After analyzing all options, here's the optimal architecture for LifeOS:

  Decision: Centralized Hybrid Filtering in Email Module

  Email Module provides smart filtering as a service with three options for
  modules:

  1. Quick Filter (keyword/regex) - Fast, free, deterministic
  2. AI Filter (natural language) - Smart, cached, minimal code
  3. Hybrid (both) - Optimal: fast path + intelligent fallback

  ---
  Why This is Best

  Cost Comparison

  | Approach                      | AI Calls/Day | Annual Cost | Performance
                     |
  |-------------------------------|--------------|-------------|------------
  -------------------|
  | No AI (pure pub/sub)          | 0            | $0          | Fast but
  brittle              |
  | Hybrid (recommended)          | ~50          | $9/year     | 1ms quick +
   500ms AI fallback |
  | Centralized AI (all emails)   | 200          | $36/year    | Always
  500ms                  |
  | Decentralized AI (per module) | 1,000        | $182/year   | Wasteful
                     |

  Hybrid wins: 75% cheaper than centralized AI, 95% cheaper than
  decentralized!

  Performance Breakdown

  For 200 emails/day:
  - 100 emails → Quick filter matches (invoices, known senders) → 1ms, $0
  - 50 emails → Quick filter rejects (spam, newsletters) → 1ms, $0
  - 50 emails → Ambiguous → 500ms, AI call → $9/year

  Average latency: 125ms (vs 500ms if AI always, or unpredictable with
  module-level AI)

  ---
  Architecture Design

  1. Module Filter Registration Interface

  // packages/core/src/module-system/IEmailFilter.ts

  interface IEmailFilter {
    moduleName: string;

    /**
     * Optional: Fast keyword/regex filter (runs first, ~1ms)
     * Return:
     *   - true: Definitely interested (skip AI)
     *   - false: Definitely not interested (skip AI)
     *   - 'uncertain': Need AI to decide
     */
    quickFilter?: (metadata: EmailMetadata) => boolean | 'uncertain';

    /**
     * Optional: AI-powered filter (runs if quickFilter returns 'uncertain')
     * Natural language description used by AI
     */
    aiFilter?: {
      description: string;     // What emails this module handles
      examples: string[];      // Example email subjects
      keywords?: string[];     // Optional high-confidence keywords
    };

    /**
     * Priority if multiple modules match (higher = higher priority)
     */
    priority?: number;
  }

  interface EmailMetadata {
    id: string;
    from: string;
    fromName?: string;
    to: string[];
    subject: string;
    snippet: string;          // First 200 chars
    hasAttachments: boolean;
    attachmentCount: number;
    labels: string[];
    timestamp: Date;
    providerMessageId: string;
    provider: EmailProvider;
  }

  ---
  2. Example Module Implementations

  Finance Module - Hybrid (Quick + AI):

  export class FinanceModule implements IModule {
    async initialize(context: ModuleContext): Promise<void> {
      // Register filter with Email Module
      context.emailModule.registerFilter({
        moduleName: 'finance',

        // Fast path: keyword matching
        quickFilter: (metadata) => {
          const subject = metadata.subject.toLowerCase();
          const from = metadata.from.toLowerCase();

          // HIGH CONFIDENCE: Definitely invoice
          if (subject.includes('invoice') ||
              subject.includes('factuur') ||
              subject.includes('receipt')) {
            return true;  // Skip AI, notify immediately
          }

          // HIGH CONFIDENCE: Definitely financial
          const financialSenders = [
            'paypal.com', 'stripe.com', 'billing@',
            'invoices@', 'accounting@'
          ];
          if (financialSenders.some(s => from.includes(s))) {
            return true;
          }

          // HIGH CONFIDENCE: Not relevant
          if (subject.includes('newsletter') ||
              from.includes('marketing@')) {
            return false;  // Skip AI, ignore
          }

          // UNCERTAIN: Could be invoice PDF, let AI decide
          if (metadata.hasAttachments &&
              (subject.includes('document') ||
               subject.includes('payment'))) {
            return 'uncertain';  // Ask AI
          }

          return false;  // Default: not interested
        },

        // AI fallback: for ambiguous emails
        aiFilter: {
          description: `
            Financial emails including:
            - Invoices and receipts (PDF or inline)
            - Payment confirmations (PayPal, Stripe, bank transfers)
            - Bank statements and transaction notifications
            - Credit card bills and statements
            - Subscription renewals and billing notices
            - Tax documents and financial reports
            - Expense reimbursement emails
          `,
          examples: [
            'Invoice #12345 from Acme Corporation',
            'Your PayPal payment to Garden Supplies was successful',
            'Monthly bank statement for April 2025',
            'Credit card bill - €1,234.56 due May 15',
            'Subscription renewal: Netflix - $15.99',
            'Tax receipt for donation to charity'
          ],
          keywords: ['invoice', 'factuur', 'receipt', 'payment', 'billing',
  'statement']
        },

        priority: 10
      });

      // Subscribe to events (only receives relevant emails!)
      context.eventBus.subscribe('EmailReceived', async (event) => {
        // Email Module already filtered - this IS relevant
        await this.emailQueue.add('process-email', {
          emailId: event.payload.id,
          metadata: event.payload
        });
      });

      // ... worker setup
    }
  }

  Garden Module - AI Only (no quick filter):

  export class GardenModule implements IModule {
    async initialize(context: ModuleContext): Promise<void> {
      context.emailModule.registerFilter({
        moduleName: 'garden',

        // No quick filter - let AI handle everything
        // (Garden emails are too varied for keywords)

        aiFilter: {
          description: `
            Garden and plant-related emails:
            - Order confirmations from garden suppliers and seed companies
            - Delivery notifications for plants, seeds, tools, fertilizer
            - Plant care tips and gardening newsletters
            - Garden service appointments (lawn care, tree trimming, 
  landscaping)
            - Seasonal planting guides and reminders
            - Communications from nurseries and garden centers
          `,
          examples: [
            'Your order of tomato seeds has shipped - tracking #ABC123',
            'Spring planting guide for your region',
            'Lawn care appointment confirmed for May 15 at 10am',
            'New arrivals: Perennial flowers for summer',
            'Delivery scheduled: 50kg organic fertilizer'
          ]
        },

        priority: 5
      });

      context.eventBus.subscribe('EmailReceived', async (event) => {
        await this.gardenEmailQueue.add('process-email', event.payload);
      });
    }
  }

  House Maintenance Module - Quick Filter Only:

  export class HouseMaintenanceModule implements IModule {
    async initialize(context: ModuleContext): Promise<void> {
      context.emailModule.registerFilter({
        moduleName: 'house-maintenance',

        // Simple keyword matching is enough (no AI needed)
        quickFilter: (metadata) => {
          const subject = metadata.subject.toLowerCase();
          const from = metadata.from.toLowerCase();

          // Utility bills
          if (subject.includes('utility') ||
              subject.includes('water bill') ||
              subject.includes('electricity') ||
              subject.includes('gas bill')) {
            return true;
          }

          // Home services
          const services = ['plumber', 'electrician', 'hvac', 'repair'];
          if (services.some(s => subject.includes(s) || from.includes(s))) {
            return true;
          }

          // HOA emails
          if (from.includes('hoa@') || subject.includes('homeowner')) {
            return true;
          }

          return false;
        },

        // No AI needed - keywords work well

        priority: 3
      });

      context.eventBus.subscribe('EmailReceived', async (event) => {
        await this.houseEmailQueue.add('process-email', event.payload);
      });
    }
  }

  ---
  3. Email Module Filter Evaluation Service

  // packages/modules/email/src/application/services/EmailFilterService.ts

  export class EmailFilterService {
    private filters: Map<string, IEmailFilter> = new Map();

    constructor(
      private aiClient: AIClient,
      private cache: CacheService
    ) {}

    registerFilter(filter: IEmailFilter): void {
      console.log(`Registered email filter for module: 
  ${filter.moduleName}`);
      this.filters.set(filter.moduleName, filter);
    }

    async evaluateFilters(metadata: EmailMetadata): Promise<string[]> {
      const startTime = Date.now();

      // Step 1: Run quick filters (synchronous, fast)
      const matchedModules: string[] = [];
      const uncertainModules: IEmailFilter[] = [];

      for (const [moduleName, filter] of this.filters) {
        if (filter.quickFilter) {
          const result = filter.quickFilter(metadata);

          if (result === true) {
            matchedModules.push(moduleName);
            console.log(`✓ Quick match: ${moduleName} (${Date.now() - 
  startTime}ms)`);
          } else if (result === 'uncertain') {
            if (filter.aiFilter) {
              uncertainModules.push(filter);
              console.log(`? Uncertain: ${moduleName} - will ask AI`);
            }
          }
          // result === false: skip module
        } else if (filter.aiFilter) {
          // No quick filter, AI evaluation needed
          uncertainModules.push(filter);
        }
      }

      // Step 2: If any modules uncertain, run ONE AI call for all
      if (uncertainModules.length > 0) {
        console.log(`Evaluating ${uncertainModules.length} modules with 
  AI...`);
        const aiMatches = await this.evaluateWithAI(metadata,
  uncertainModules);
        matchedModules.push(...aiMatches);
        console.log(`AI matches: ${aiMatches.join(', ')} (${Date.now() - 
  startTime}ms)`);
      }

      // Step 3: Sort by priority (higher first)
      const sorted = matchedModules.sort((a, b) => {
        const priorityA = this.filters.get(a)?.priority || 0;
        const priorityB = this.filters.get(b)?.priority || 0;
        return priorityB - priorityA;
      });

      console.log(`Email filtered in ${Date.now() - startTime}ms → 
  [${sorted.join(', ')}]`);
      return sorted;
    }

    private async evaluateWithAI(
      metadata: EmailMetadata,
      filters: IEmailFilter[]
    ): Promise<string[]> {
      // Check cache first (7-day TTL)
      const cacheKey = this.buildCacheKey(metadata, filters);
      const cached = await this.cache.get(cacheKey);

      if (cached) {
        console.log(`Cache hit for email filter`);
        return cached;
      }

      // Build prompt with ALL uncertain module filters
      const prompt = this.buildAIPrompt(metadata, filters);

      // Single AI call evaluates ALL modules at once
      const response = await this.aiClient.complete({
        prompt,
        temperature: 0.1,  // Low temperature for consistency
        maxTokens: 200
      });

      // Parse response: ["finance", "garden"]
      const matches = this.parseAIResponse(response);

      // Cache for 7 days (similar emails reuse decision)
      await this.cache.set(cacheKey, matches, 604800);

      return matches;
    }

    private buildAIPrompt(
      metadata: EmailMetadata,
      filters: IEmailFilter[]
    ): string {
      const moduleDescriptions = filters
        .filter(f => f.aiFilter)
        .map(f => {
          const ai = f.aiFilter!;
          return `
  ## ${f.moduleName}
  ${ai.description}

  Example emails this module handles:
  ${ai.examples.map(ex => `- ${ex}`).join('\n')}

  ${ai.keywords ? `High-confidence keywords: ${ai.keywords.join(', ')}` : 
  ''}
  `;
        })
        .join('\n---\n');

      return `
  You are an email routing assistant. Analyze the email below and determine 
  which module(s) should process it.

  # Email Details
  From: ${metadata.from}${metadata.fromName ? ` (${metadata.fromName})` : 
  ''}
  To: ${metadata.to.join(', ')}
  Subject: ${metadata.subject}
  Preview: ${metadata.snippet}
  Has Attachments: ${metadata.hasAttachments ? `Yes 
  (${metadata.attachmentCount})` : 'No'}
  Timestamp: ${metadata.timestamp.toISOString()}

  # Available Modules
  ${moduleDescriptions}

  # Instructions
  Determine which module(s) should handle this email. Consider:
  1. Does the email content match the module's description?
  2. Would the module find value in processing this email?
  3. Multiple modules can handle the same email if relevant to both

  Respond with ONLY a JSON array of module names that match, or empty array 
  if none:
  ["finance"] or ["garden", "house"] or []

  Response:`;
    }

    private parseAIResponse(response: string): string[] {
      try {
        // Extract JSON array from response
        const jsonMatch = response.match(/\[.*?\]/s);
        if (!jsonMatch) {
          console.error('No JSON array found in AI response');
          return [];
        }

        const modules = JSON.parse(jsonMatch[0]);

        if (!Array.isArray(modules)) {
          console.error('AI response is not an array');
          return [];
        }

        return modules.filter(m => typeof m === 'string');
      } catch (error) {
        console.error('Failed to parse AI response:', error);
        return [];
      }
    }

    private buildCacheKey(metadata: EmailMetadata, filters: IEmailFilter[]):
   string {
      // Hash based on sender domain + subject keywords + module set
      const domain = metadata.from.split('@')[1] || metadata.from;
      const keywords = this.extractKeywords(metadata.subject).slice(0,
  3).join('-');
      const moduleNames = filters.map(f => f.moduleName).sort().join('-');

      return `email-filter:${domain}:${keywords}:${moduleNames}`;
    }

    private extractKeywords(text: string): string[] {
      // Extract meaningful words (ignore common words)
      const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in',
   'on', 'at', 'to', 'for']);

      return text
        .toLowerCase()
        .replace(/[^\w\s]/g, '')
        .split(/\s+/)
        .filter(word => word.length > 3 && !stopWords.has(word))
        .slice(0, 5);
    }
  }

  ---
  4. Email Module Integration

  // packages/modules/email/src/EmailModule.ts

  export class EmailModule implements IModule {
    name = 'email';
    version = '1.0.0';

    private filterService: EmailFilterService;
    private syncService: EmailSyncService;

    async initialize(context: ModuleContext): Promise<void> {
      // Initialize filter service
      this.filterService = new EmailFilterService(
        context.aiClient,
        context.cache
      );

      // ... other initialization
    }

    /**
     * Public API: Modules register their email filters
     */
    registerFilter(filter: IEmailFilter): void {
      this.filterService.registerFilter(filter);
    }

    /**
     * Internal: Called when email arrives
     */
    private async handleEmailArrival(metadata: EmailMetadata): Promise<void>
   {
      // 1. Evaluate filters (quick + AI)
      const interestedModules = await
  this.filterService.evaluateFilters(metadata);

      if (interestedModules.length === 0) {
        console.log(`No modules interested in email: ${metadata.subject}`);
        await this.eventBus.publish({
          type: 'EmailIgnored',
          source: 'email',
          payload: { emailId: metadata.id, reason: 'No interested modules' }
        });
        return;
      }

      // 2. Publish event ONLY to interested modules
      // (Optional: could publish module-specific events for better 
  targeting)
      await this.eventBus.publish({
        type: 'EmailReceived',
        source: 'email',
        payload: metadata,
        metadata: {
          interestedModules  // Modules can check if they're in this list
        }
      });

      console.log(`✓ Email routed to: ${interestedModules.join(', ')}`);
    }

    /**
     * Public API: Modules fetch full email (lazy loading)
     */
    async getEmail(emailId: string): Promise<Result<EmailContent,
  BaseError>> {
      const useCase = new GetEmailUseCase(
        this.emailRepository,
        this.emailProviderFactory,
        this.emailCache
      );
      return await useCase.execute(emailId);
    }
  }

  ---
  5. Complete Flow Diagram

  ┌──────────────────────────────────────────────────────────────┐
  │          Email arrives at Gmail/Outlook/SMTP                  │
  └─────────────────────────┬────────────────────────────────────┘
                            │
                            │ Webhook notification
                            ▼
  ┌──────────────────────────────────────────────────────────────┐
  │         Email Module - SyncEmailsUseCase                      │
  │  1. Fetch metadata from provider                             │
  │  2. Store in database                                        │
  │  3. Trigger filter evaluation                                │
  └─────────────────────────┬────────────────────────────────────┘
                            │
                            ▼
  ┌──────────────────────────────────────────────────────────────┐
  │           EmailFilterService.evaluateFilters()                │
  │                                                               │
  │  Step 1: Run Quick Filters (1-5ms)                          │
  │    Finance.quickFilter(metadata)                             │
  │      → "invoice" in subject → TRUE ✓                         │
  │    Garden.quickFilter(metadata)                              │
  │      → not from supplier → FALSE ✗                           │
  │    House.quickFilter(metadata)                               │
  │      → has attachment, ambiguous → UNCERTAIN ?               │
  │                                                               │
  │  Results: matched=[finance], uncertain=[house]               │
  └─────────────────────────┬────────────────────────────────────┘
                            │
                            ▼
  ┌──────────────────────────────────────────────────────────────┐
  │         Step 2: AI Evaluation (if uncertain modules)          │
  │                                                               │
  │  1. Check cache (key: domain + keywords + modules)           │
  │     Cache miss                                               │
  │                                                               │
  │  2. Build AI prompt with House module's aiFilter             │
  │                                                               │
  │  3. ONE AI call: "Is this email for house module?"           │
  │     Response: ["house"] ✓                                    │
  │                                                               │
  │  4. Cache result for 7 days                                  │
  │                                                               │
  │  Total time: ~500ms                                          │
  └─────────────────────────┬────────────────────────────────────┘
                            │
                            ▼
  ┌──────────────────────────────────────────────────────────────┐
  │       Combine Results: ["finance", "house"]                   │
  │       (Garden module NOT notified - saves CPU)                │
  └─────────────────────────┬────────────────────────────────────┘
                            │
                            ▼
  ┌──────────────────────────────────────────────────────────────┐
  │            Publish EmailReceived Event                        │
  │  payload: { ...metadata }                                    │
  │  metadata: { interestedModules: ["finance", "house"] }       │
  └──────────────┬───────────────────────┬───────────────────────┘
                 │                       │
                 ▼                       ▼
  ┌──────────────────────┐   ┌──────────────────────┐
  │  Finance Module      │   │  House Module        │
  │  (subscribed)        │   │  (subscribed)        │
  │                      │   │                      │
  │  Checks if in list ✓ │   │  Checks if in list ✓ │
  │  Adds to queue       │   │  Adds to queue       │
  └──────────┬───────────┘   └──────────┬───────────┘
             │                          │
             ▼                          ▼
      Worker processes         Worker processes
      email in background      email in background

  ---
  Benefits of Hybrid Approach

  1. Cost Optimization

  - $9/year vs $36 (centralized AI) or $182 (decentralized AI)
  - Only pay for AI when actually needed
  - Caching reduces duplicate AI calls by ~70%

  2. Performance

  - Quick filters: 1-5ms (keywords/regex)
  - AI fallback: ~500ms (only 25% of emails)
  - Average: ~125ms per email
  - No wasted worker activations

  3. Flexibility

  - Modules choose: quick, AI, or hybrid
  - Start simple (keywords), add AI later
  - Each module controls own logic
  - Progressive enhancement

  4. Scalability

  - Centralized caching benefits all modules
  - One AI call evaluates multiple modules
  - Email Module optimizes on behalf of all modules
  - Easy to add new modules (just register filter)

  5. Reliability

  - Quick filters never fail (deterministic)
  - AI failures fall back to conservative routing (notify all)
  - Cache provides resilience
  - Event sourcing provides audit trail

  ---
  Implementation Priority

  Phase 1: Core (Week 1)
  - EmailFilterService with quick filter support
  - Filter registration API
  - Basic event publishing (no AI yet)

  Phase 2: AI Integration (Week 2)
  - Add AI evaluation for uncertain cases
  - Implement caching strategy
  - Test with Finance module (hybrid filter)

  Phase 3: Module Examples (Week 3)
  - Finance module: hybrid (quick + AI)
  - Garden module: AI only
  - House module: quick only
  - Compare performance

  ---
  Final Recommendation

  ✅ Implement Hybrid Filtering in Email Module

  This architecture gives you:
  - Best cost/performance ratio ($9/year, 125ms average)
  - Maximum flexibility (modules choose filtering strategy)
  - Centralized optimization (caching, batching)
  - Decentralized control (modules own logic)

  The Email Module becomes a smart filtering service that modules leverage,
  rather than a dumb broadcast system or an opinionated AI router.

  Should I start implementing this? I can create:
  1. Core filter interfaces and EmailFilterService
  2. Example Finance module with hybrid filter
  3. Complete integration with EventBus
  4. Tests showing quick filter → AI fallback flow



